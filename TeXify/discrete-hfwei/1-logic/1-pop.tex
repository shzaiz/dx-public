
    从高中开始, 我们似乎就开始处理各种各样的命题. 下面我们加一层抽象, 这样, 我们就可以把一些繁琐的内容交给计算机完成, 并且在探索的过程中对``什么是有效的推理''有一个更深的理解. 
    \begin{definition}[命题 (Proposition)]
        {\bf 命题}是可以判定真假的陈述句 (不可既真又假). 
      \end{definition}

    \subsection{命题逻辑}

    \subsubsection{命题逻辑的语言}
    所以, 要完成这项任务, 第一步就是尽可能地形式化的描述一下这些一直在用的语言. 
    \begin{definition}[命题逻辑的语言]
        命题逻辑的语言有且仅有如下的内容构成: 
        \begin{itemize}
            \item 任意多的命题符号
            \item 5个逻辑连接词(见下表\ref{fig-conn})
            \item 左括号, 右括号
        \end{itemize}
    \end{definition}
    \input{1-logic/table/conn.tex}

    \begin{definition}[公式]
        如果一个串是公式, 那么: 
        \begin{itemize}
            \item 每个命题符号都是公式;
            \item 如果 $\alpha$ 和 $\beta$都是公式,
              则 $(\lnot \alpha)$, $(\alpha \land \beta)$, $(\alpha \lor \beta)$,
              $(\alpha \to \beta)$ 和 $(\alpha \leftrightarrow \beta)$ 也是公式;
            \item 除此之外, 别无其它. 
        \end{itemize}
    \end{definition}

    这里出现了很类似定义自然数的定义方法, 一个很自然的想法是我们能不能在这里运用数学归纳法. 答案是可以的. 我们称作``归纳原理''. 
    
    \begin{theorem}[归纳原理]
        令 $P(\alpha)$ 为一个关于公式的性质. 假设
        \begin{itemize}
          \item 对所有的命题符号 $A_{i}$, 性质 $P(A_{i})$ 成立; 并且
          \item 对所有的公式$\alpha$和$\beta$, 如果 $P(\alpha)$和$P(\beta)$成立,
            则 $P((\lnot \alpha))$, $P((\alpha \;{\ast}\; \beta))$ 也成立,
        \end{itemize}
        那么 $P(\alpha)$ 对所有的公式 $\alpha$ 都成立. 
      \end{theorem}
      \begin{bonus}
        数学归纳法可以在正整数上使用, 但是不能再$\R$上使用, 却可以在上面定义的结构中使用, 为什么? 什么样的结构可以运用数学归纳法?
      \end{bonus}
      
      规定了符号, 就一定要有对应的运算规律. 因此, 我们就给出如下定义, 和高中的内容类似. 

      \begin{definition}[命题符号的运算规则]
        一般地, 命题记号遵循如下的运算规则: 
        \begin{itemize}
            \setlength{\itemsep}{6pt}
            \item 最外层的括号可以省略
            \item 优先级: $\lnot$, $\land$, $\lor$, $\to$, $\leftrightarrow$
            \item 结合性: 右结合 ($\alpha \land \beta \land \gamma$,
              $\alpha \to \beta \to \gamma$)
          \end{itemize}
        
      \end{definition}
      
      有了命题, 我们很多时候希望``假定''这些命题的真假, 来考察最终结论的真假, 或者从中找到一点规律. 这样做其实有一个更专业的名字叫``真值指派''. 

      \begin{definition}[真值指派 ($v$)]
        令 $S$ 为一个命题符号的集合. 
        $S$ 上的一个{\bf 真值指派} $v$ 是一个从 $S$ 到真假值的映射
        \[
          v: S \to \{T, F\}.
        \]
      \end{definition}

      如果对于只能指派一个的话太局限了, 我们不妨把所有可能的情况都枚举一遍映射过去. 也就是真值指派的``扩张''.

      \begin{definition}[真值指派的扩张 ($\overline{v}$)]
        令 $S$ 为一个命题符号的集合. 
        令 $\overline{S}$ 为只含有 $S$ 中命题符号的公式集. 
    
        $S$ 上的{\bf 真值指派 $v$ 的扩张}是一个从 $\overline{S}$ 到真假值的映射
        \[
          \overline{v}: \overline{S} \to \{T, F\}.
        \]
      \end{definition}

      \begin{definition}[满足 (Satisfy)]
        如果 $\overline{v}(\alpha) = T$, 则称真值指派 $v$ {\bf 满足}公式 $\alpha$. 
      \end{definition}

      很多时候一些逻辑表达式看上去就是废话. 比如``如果我后天知道了考试的成绩, 那我明天就知道了''. 数学上面对这类问题有一个定义叫做``重言蕴含''. 

      \begin{definition}[重言蕴含 (Tautologically Implies)]
          设 $\Sigma$ 为一个公式集. 
    
          $\Sigma$ {\bf 重言蕴含}公式 $\alpha$,
          记为 $\Sigma \models \alpha$,
    
          如果{每个}满足 $\Sigma$ 中{所有}公式的真值指派都满足 $\alpha$. 
      \end{definition}

      \begin{definition}[重言式/永真式 (Tautology)]
        如果 $\emptyset \models \alpha$, 则称 $\alpha$ 为{\bf 重言式},
        记为 $\models \alpha$. 
      \end{definition}

      反之, 就是永远都不能成立的矛盾的形式. 
      
      \begin{definition}[矛盾式/永假式 (Contradiction)]
        若公式 $\alpha$ 在所有真值指派下均为假, 则称 $\alpha$ 为{\bf 矛盾式}. 
      \end{definition}

      \begin{definition}[重言等价 (Tautologically Equivalent)]
        如果 $\alpha \models \beta$ 且 $\beta \models \alpha$,
        则称 $\alpha$ 与 $\beta$ {\bf 重言等价}, 记为 $\alpha \equiv \beta$. 
      \end{definition}

      \subsubsection{命题逻辑的运算律}

      上面我们发现了有很多的废话, 但是, 有时候``废话''并不是显然的. 这就需要一些推理规律来帮助我们联通看上去毫不相干的逻辑符号. 

      \begin{proposition}(逻辑的运算律)
        \begin{itemize}
            
            \item 交换律:
          \[
            (A \land B) \leftrightarrow (B \land A)
          \]
          \[
            (A \lor B) \leftrightarrow (B \lor A)
          \]
        \item 结合律:
          \[
            ((A \land B) \land C) \leftrightarrow (A \land (B \land C))
          \]
          \[
            ((A \lor B) \lor C) \leftrightarrow (A \lor (B \lor C))
          \]
        \item 分配律:
          \[
            (A \land (B \lor C)) \leftrightarrow ((A \land B) \lor (A \land C))
          \]
          \[
            (A \lor (B \land C)) \leftrightarrow ((A \lor B) \land (A \lor C))
          \]
        \item De Morgan律: 
          \[
            \lnot (A \land B) \leftrightarrow (\lnot A \lor \lnot B)
          \]
          \[
            \lnot (A \lor B) \leftrightarrow (\lnot A \land \lnot B)
          \]
          \item 双重否定律:
            \[
                \lnot \lnot A \leftrightarrow A
            \]
            \item 排中律:
            \[
                A \lor (\lnot A)
            \]
            \item 矛盾律:
            \[
                \lnot (A \land \lnot A)
            \]
            \item 逆否命题:
            \[
                (A \to B) \leftrightarrow (\lnot B \to \lnot A)
            \]
        \end{itemize}
        
      \end{proposition}

      那么, 这些内容化简到最后有没有一个目标呢? 其实是有的. 任何一个命题都可以写成``合取范式(CNF)''或者``析取范式''的形式. 下面给出定义. 
      
      \begin{definition}[合取范式 (Conjunctive Normal Form)]
            我们称公式 $\alpha$ 是{\bf 合取范式}, 如果它形如
            \[
              \alpha = \beta_{1} \land \beta_{2} \land \dots \land \beta_{k},
            \]
            其中, 每个 $\beta_{i}$ 都形如
            \[
              \beta_{i} = \beta_{i1} \lor \beta_{i2} \lor \dots \lor \beta_{in},
            \]
            并且 $\beta_{ij}$ 或是一个命题符号, 或者命题符号的否定. 
    \end{definition}

    \begin{definition}[析取范式 (Disjunctive Normal Form)]
            我们称公式 $\alpha$ 是{\bf 析取范式}, 如果它形如
            \[
              \alpha = \beta_{1} \lor \beta_{2} \lor \dots \lor \beta_{k},
            \]
            其中, 每个 $\beta_{i}$ 都形如
            \[
              \beta_{i} = \beta_{i1} \land \beta_{i2} \land \dots \land \beta_{in},
            \]
            并且 $\beta_{ij}$ 或是一个命题符号, 或者命题符号的否定. 
    \end{definition}

    \begin{bonus}
      根据上述的演算的规则, 有没有一种操作方法, 应该怎样把一个命题化作一个CNF或者BNF?
    \end{bonus}

    \subsubsection{命题逻辑的演算}

    命题逻辑的演算有时候也可以帮助我们理解命题之间的等价关系. 

    \textbf{引入假设.}
    \[
        \frac{~}{[x : P]} \qquad\texttt{(assumption)}
    \] 
    所有引入的假设最终必须被``{\bf 释放}'' (discharged)
    所谓释放, 其实就是在使用假设$\alpha$作为假设的前提下推出了$\beta$, 最后要写成$\alpha \rightarrow \beta$的形式. 这就是假设的释放. 

    \textbf{``$\land$''推理规则.}
    \begin{gather*}
        \frac{P \qquad Q}{P \land Q} \qquad{\land\texttt{-intro}}\\
        \frac{P \land Q}{P}\qquad{\land\texttt{-elim-left}}\\
        \frac{P \land Q}{Q}\qquad{\land\texttt{-elim-right}}
    \end{gather*}
    
    下面这条规则描述了双重否定的性质. 
    
    \textbf{``$\lnot\lnot$''推理规则.}

    \[
        \frac{\alpha}{\lnot \lnot \alpha}{\lnot\lnot\texttt{-intro}}
    \]

    \[
        \frac{\lnot \lnot \alpha}{\alpha}{\lnot\lnot\texttt{-elem}}
    \]
    
    \textbf{``$\to$''推理规则.}
    
    \begin{gather*}
        \frac{\alpha \to \beta \qquad \alpha}{\beta}\qquad {\to\texttt{-elim (modus ponens)}}
        \\
        \frac{\alpha \to \beta \qquad \lnot \beta}{\lnot \alpha}{\texttt{modus tollens}}
        \\
        \frac{\stackrel{[x \;:\; \alpha]}{\stackrel{\vdots}{\beta}}}{\alpha \to \beta}\qquad {\to\texttt{-intro}/x} \\
        \texttt{{Assumption $x$ is discharged}}
      \end{gather*}

    \textbf{$\lor$推理规则.}
    \[
    \frac{\alpha}{\alpha \lor \beta}\qquad {\lor\texttt{-intro-left}}
    \]

    \[
    \frac{\alpha \lor \beta \qquad \alpha \to \gamma \qquad \beta \to \gamma}{\gamma}\qquad {\lor\texttt{-elim; (分情况分析)}}
    \]

    \textbf{$\bot$推理规则.}

    \[
    \frac{\alpha \qquad \lnot \alpha}{\bot}\qquad {\bot\texttt{-intro}}
  \]

  \[
    \frac{\bot}{\alpha}\qquad {\bot\texttt{-elim(Principle of Explosion)}; }
  \]

  \textbf{``$\lnot$''.推理规则}

  \begin{gather*}
    \frac{\alpha \to \bot}{\lnot \alpha}\qquad {\lnot\texttt{-intro}} 
    \frac{\lnot \alpha}{\alpha \to \bot}\qquad {\lnot\texttt{-elim}}
  \end{gather*}

  \begin{theorem}[命题逻辑的可靠性 (Soundness)]
    如果 $\Sigma \vdash \alpha$, 则 $\Sigma \models \alpha$. 
  \end{theorem}

  \begin{theorem}[命题逻辑的完备性 (Completeness)]
    如果 $\Sigma \models \alpha$, 则 $\Sigma \vdash \alpha$. 
  \end{theorem}
  
\part{递归与回溯}

\section{问题的简化}

我们常说: ``大事化小, 小事化了''. 比如, 你在做数学计算的$3+2+4+5$这个
表达式的时候, 你可能会自动先计算$3+2=5$, 然后再继续计算$5+4+5$. 这样
一来, 我们距离结果就更进一步了. 也就是问题变得更``小''了, 或者更``容易''
解决了. 有些时候, 我们甚至允许把整个过程用抽象的方法盖住了. 比如, 你做了
一个摄氏度转华氏度的转换器, 你可以用一个函数把它抽象, 这样一来, 下次使用
的时候就直接调用就行了. 

我们来看一些我们如何简化问题的一些例子: 

\begin{example}
    要计算一个正整数$n$的阶乘, 如果它不是1或者0, 那么计算$n*(n-1\text{的阶乘})$.
    用数学的语言来写就是
    $f(x)=\begin{cases}
    x\cdot f(x-1) & x>1\\
    1 & x=1
    \end{cases}$
    这就意味着, 我们每一次计算的阶乘都比原来的更靠近答案. 如果我们实际写一下$f(5)$, 
    我们就会有如下过程(为了方便起见, 我们使用$f(x)$表示$x$的阶乘
    ): 
    $$
        f(5) = 5\times f(4) = 5\times 4\times f(3) = 5\times 4\times 3 \times f(2)
        = 5\times 4\times 3\times 2\times f(1) = 5\times 4\times 3\times 2\times 1.  
    $$
\end{example}

\begin{example}
    TBD % TODO
\end{example}

\section{解决小问题, ``顺便''解决了大问题}

实际上, 有一类问题它比较特殊. 你会发现, 如果能够把小问题解决好了, 那么原来的大问题
就自然而然地解决好了. 这种情形, 我们一般认为是递归的问题. 

\begin{definition}
    递归的问题是这样解决的: 
    \begin{itemize}
        \item 如果给定的问题大小可以直接解决, 那么就直接解决了; 
        \item 否则, 把它转化为这个问题的更简单(通常会更小)的问题
    \end{itemize}
\end{definition}

一开始, 这样自己提及自己的内容的确让人困惑. 但是, 有一个有趣的方法, 就是假想
有一个小精灵帮助你解决问题 - 我喜欢称他为递归精灵. 
你唯一的任务是简化原来的问题, 或者在不必要或不可能简化的情况下直接解决它. 
递归精灵将使用与你无关的方法为你解决所有更简单的子问题. 

这样说来确实很困惑. 但是我们来看下面的几个例子: 

\begin{example}
    TBD: 归并排序
\end{example}


\begin{example}
    TBD: Hanoi 塔问题
\end{example}

\section{递归与``状态''们}

从这里开始, 我们对于程序的执行的理解似乎就感觉有点模糊了. 不过我们总是可以
使用正确的工具来让我们了解更多. 具体地, 我们可以使用调试功能. 调试器可以
帮助我们窥探程序现在在执行哪一行, 执行的内容是什么. 以及执行到这一步里面的
变量有什么, 是什么值. 我们可以使用$\texttt{gdb}$来解答这个问题. 

我们可以把每一次这样的函数调用想象是一个状态. 所谓状态, 就是相当于给这时候
程序里面的内容拍了个照. 研究状态是如何变化的会让我们思路更加清晰. 我们首先从
Hanoi塔开始看起: 

TBD




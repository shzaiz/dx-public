\part{递归问题}

\section{问题的简化和递归的过程}

我们常说: ``大事化小, 小事化了''. 比如, 你在做数学计算的$3+2+4+5$这个
表达式的时候, 你可能会自动先计算$3+2=5$, 然后再继续计算$5+4+5$. 这样
一来, 我们距离结果就更进一步了. 也就是问题变得更``小''了, 或者更``容易''
解决了. 有些时候, 我们甚至允许把整个过程用抽象的方法盖住了. 比如, 你做了
一个摄氏度转华氏度的转换器, 你可以用一个函数把它抽象, 这样一来, 下次使用
的时候就直接调用就行了. 

我们来看一些我们如何简化问题的一些例子: 

\begin{example}
    要计算一个正整数$n$的阶乘, 如果它不是1或者0, 那么计算$n*(n-1\text{的阶乘})$.
    用数学的语言来写就是
    $f(x)=\begin{cases}
    x\cdot f(x-1) & x>1\\
    1 & x=1
    \end{cases}$
    这就意味着, 我们每一次计算的阶乘都比原来的更靠近答案. 如果我们实际写一下$f(5)$, 
    我们就会有如下过程(为了方便起见, 我们使用$f(x)$表示$x$的阶乘
    ): 
    $$
        f(5) = 5\times f(4) = 5\times 4\times f(3) = 5\times 4\times 3 \times f(2)
        = 5\times 4\times 3\times 2\times f(1) = 5\times 4\times 3\times 2\times 1.  
    $$
\end{example}

\begin{example}
    要学习知识, 首先要认真理解课本的内容, 然后自己进行思考, 最后对于一些问题
    进行提问. % TODO
\end{example}


实际上, 有一类问题它比较特殊. 你会发现, 如果能够把小问题解决好了, 那么原来的大问题
就自然而然地解决好了. 这种情形, 我们一般认为是递归的问题. 

\begin{definition}[递归]
    递归的问题是这样解决的: 
    \begin{itemize}
        \item 如果给定的问题大小可以直接解决, 那么就直接解决了; 
        \item 否则, 把它转化为这个问题的更简单(通常会更小)的问题
    \end{itemize}
\end{definition}

一开始, 这样自己提及自己的内容的确让人困惑. 但是, 有一个有趣的方法, 就是假想
有一个小精灵帮助你解决问题 - 我喜欢称他为递归精灵. 
你唯一的任务是简化原来的问题, 或者在不必要或不可能简化的情况下直接解决它. 
递归精灵将使用与你无关的方法为你解决所有更简单的子问题. 

这样说来确实很困惑. 但是我们来看下面的几个例子: 

\begin{example}
    归并排序: 要排序一列数, 我们可以将待排序的序列分成两个子序列,
    然后分别对这两个子序列进行递归排序,最后将两个有序的子序列合并成一个有序的序列.
    \mn{在合并的过程中, 我们还可以计算逆序对.}
    这时候, 我们将问题分解成若干个相同或相似的相似的小问题来解决, 
    然后再将子问题的解合并起来, 得到原问题的解. \file{mg-sort}
\end{example}

\ti{P1908 逆序对} 我们可以借鉴快速排序的思想的合并过程中作为合并的时候统计. 
如果左边有$m$个逆序对, 右边有$n$个逆序对, 那么就会多出$mid-i+1$个. 见
代码\file{inversion-pair}. 

\begin{example}
    TBD: Hanoi 塔问题
\end{example}


从这里开始, 我们对于程序的执行的理解似乎就感觉有点模糊了. 不过我们总是可以
使用正确的工具来让我们了解更多. 具体地, 我们可以使用调试功能. 调试器可以
帮助我们窥探程序现在在执行哪一行, 执行的内容是什么. 以及执行到这一步里面的
变量有什么, 是什么值. 我们可以使用$\texttt{gdb}$来解答这个问题. 

我们可以把每一次这样的函数调用想象是一个状态. 所谓状态, 就是相当于给这时候
程序里面的内容拍了个照. 研究状态是如何变化的会让我们思路更加清晰. 我们首先从
Hanoi塔开始看起: 

TBD

\section{递归的结构}

\lec{引用}{重要的操作} 可能发生过这样的情形: 假设你是一个课代表, 你希望去某一个老师那里抱作业. 
但是你不知道这位老师住在哪. 现在, 有同学告诉你老师在309办公室. 这下, 你就可以使用
知道的``309''来找到老师了. 

看似这是一个不起眼的例子, 实际上, 这包含着计算机科学里面比较重要的内容: 使用一种间接
的方式来获得我们要的东西. 

\lec{链表}{单向} 链表是它由一系列节点组成, 每个节点包含两部分：
数据 (存储我们需要的信息) 和指针 (指向下一个节点的地址) . 
链表中的节点可以分散存储在内存中, 不像数组那样需要一段连续的内存空间. 
这就可以方便地在中间插入与删除元素. 但是我们的随机查找的功能就不能
很快地完成了. 因为它们在内存里面不是连续的. 

链表可以被看作是一个递归结构, 即链表的每个节点都可以看作是一个小型的链表. 
每个节点包含数据和指向下一个节点的指针, 而下一个节点又包含数据和指向更下一个节点的指针, 
以此类推. 
原来即使在一些结构里面, 递归的问题也是大有帮助的. 

\ti{UVA11998 Broken Keyboard} TBD 

\lec{链表}{双向} 当然有些问题我们还可以记录双向的信息, 也就是它的上一个和下一个. 这里有一个
经典的问题. 我们可能需要很长时间才能够把它调试正确. \ti{UVA12657 移动盒子}.

\lec{树状结构}{二叉树} 

我们窗外应该就有很多树. 我们现在来看树状的结构. 

二叉树是一种特殊的树结构，其中每个节点最多有两个子节点，通常称为左子节点和右子节点。
这个定义是递归的，因为二叉树的每个子树也是一个二叉树。

具体地说，二叉树可以为空，也就是没有节点的情况，这被称为空二叉树或空树。
如果二叉树不为空，则它由一个根节点组成，以及两个分别为根节点的左子树和右子树的二叉树。

递归定义的核心是，二叉树的每个子树仍然是一个二叉树，它们也遵循相同的定义：
最多有两个子节点，每个节点都可以有自己的左子节点和右子节点，或者为空。这种递归定义使得
我们可以在处理二叉树时使用递归的思想，对于每个节点，
我们可以递归地处理它的左子树和右子树。递归在二叉树的许多问题中都是非常常见和有效的解决方法。

一个问题是, 如何储存二叉树呢? 一个想法是, 我们假设考虑一个最满的二叉树, 应该是如下图所示的: 
\incfig{recursion/bintree.jpeg}
自然, 我们就可以为他们天然指定一个序号. 我们采用这样的方式: 对于一个节点编号为$o$
, 左孩子我们可以使用$o\times 2$来表示, 右孩子我们可以使用$o\times 2+1$来表示. 
这样子, 我们就可以来储存这棵树了. 

但问题又来了: 我们现在是按照满的样子去精简的. 假设我们这个是一条链, 也就是层数
很深, 但是节点数很稀疏, 这时候如何是好? 这时候, 我们用到这样的一个技术了:
我们主要维护一个新节点的``池子'', 里面的每一个表示一个新节点的编号.
每次我们要新建一个节点的话, 就可以通过让这个池子的数据加1的方式. 这时候, 我们 
可以使用编号的方式去更新与原来的关系. 实际上, 用一个``池子''这样的思路
其实是使用了数组模拟指针的思想. 现在使用指针可能会造成一些误解, 所以先使用
数组模拟的指针做大致了解. 

TBD: 添加数组模拟指针的代码...

既然树是递归的结构, 那么, 自然我们更希望使用递归的方法去处理它. 不过, 
因为它有两个子节点, 我们才感觉它和一般的线性的数据有一些不同. 

一个递归函数, 当然可能要决定什么时候递归, 什么时候对我们当前的节点做操作. 
时机是很重要的. 

\lec{二叉树的三种遍历模式}{前序遍历} 前序遍历的过程是, 先输出当前的节点, 再
递归地前序遍历左边的孩子, 再递归地前序遍历右边的孩子. 我们对于样例的树模拟一下. 
\begin{lstlisting}
void pre_order(int o){
    if(o does not exist) return;
    print(o);
    pre_order(o's left son);
    pre_order(o's right son);
}
\end{lstlisting}

\lec{二叉树的三种遍历模式}{中序遍历} 中序遍历的过程是, 先
递归地中序遍历左边的孩子, 再输出根节点,再递归地遍历右边的孩子. 
\begin{lstlisting}
    void in_order(int o){
        if(o does not exist) return;
        in_order(o's left son);
        print(o);
        in_order(o's right son);
    }
\end{lstlisting}

\lec{二叉树的三种遍历模式}{后序遍历} 后序遍历的过程是, 先
递归地中序遍历左边的孩子,再递归地遍历右边的孩子, 最后输出根节点. 
\begin{lstlisting}
    void in_order(int o){
        if(o does not exist) return;
        post_order(o's left son);
        post_order(o's right son);
        print(o);
    }
\end{lstlisting}

这三个内容看起来就是一些奇怪的交换顺序, 实际上, 我们有很多的有趣的性质可以从中
观察出来. 比如, 前序遍历的一个内容总是根. 那么, 能不能通过前序遍历的序列和中序遍历
的序列还原整个二叉树呢? 其实是可以的. 既然前序遍历的一个内容总是根, 中序遍历只要
找到这个根在哪就可以了. 中间的就是子树. 子树也可以按照同样的方法做. 

\ti{P1030 求先序排列} 这个问题只是变了一下形式, 后序遍历了. 但是后序遍历根节点
在最后输出. 和上面的讨论是一致的. 

我们之所以能够按照这种方法遍历, 说到底还是用好了递归的结构的定义. 下面我们来看一看
有什么有趣的遍历方法. 

\ti{UVA10562 Underdraw the trees} 题目大意: 你的任务是把多叉树写成括号的表示法. 
每个节点处了``-'', ``|'', `` ''(空格)用其他字符表示, 每个非叶子节点下方总会有一个
``|''字符, 下方是一排``-''字符, 恰好覆盖在所有的子节点上面. 单独的一行``\#''作为结束标记.

我们可以定义函数\cw{dfs(r,c)}表示\cw{r}行 \cw{c}列开始的内容. 下面有子树的条件
是下一行的这一列有\cw{|}记号(注意不要越界). 然后我们就可以寻找\cw{-} 的左边界, 
顺着\cw{-}走, 一旦发现下面有字符就继续递归下去. 

刚刚的问题甚至不是二叉树, 但是我们运用我们的方法照样可以继续下去. 

\ti{UVA297 Quadtrees} 这是一个四叉树的问题. 但是解决问题的思路也是类似的. 
这时候我们把两个内容都画出来就好了. 这样子模拟一遍就完成了. 

\ti{UVA806 Spatial Structures} 

接下来我们来看求最短路的一些方法. 除了一路走到底, 我们能不能边走边看呢? 我们可以
使用BFS的方法. 具体而言, 我们的策略如下: 
\begin{lstlisting}
queue=[起点]
while(queue不是空的){
    node = 队列的第一个元素;
    输出node;
    把所有与node能够到达的没有访问过的边放进来;
}
\end{lstlisting}

我们来看一个迷宫游戏, 并且在上面运用一下我们的BFS技术. TBD. 

我们发现我们搜到的结果其实就是一棵树. 

\lec{多说一句}{了解计算机程序的执行} 其实, 我们刚刚发现的树, 有一些类似的
妙用. 不过我们要加上允许环的形成. 也就是, 现在它是一些点和一些边的集合.
它甚至可以帮助我们理解我们的程序. 其实, 每一个程序都可以被抽象为一个
执行的图. 

到底什么是程序? 我们看上去我们会认为是我们的C代码, 经过下面的内容, 希望大家可以
对于``什么是程序''有一个不一样的答案. 我们会用刚刚我们了解到的``图''的知识, 
构建一个``状态机模型''. \cite{jyyos-prog}

``到底什么是程序''这样的问题是比较深刻的. 理论计算机学家深刻地研究了程序语言应该
有的语义, 执行的过程等等. 但是我们从一个更加简化的角度来看, \textbf{程序就是
状态机}. 每一个状态就相当于一个节点里的一些数据, 不同状态之间经过程序语句
进行转移. 一个粗浅的理解是是: 状态就是``堆 + 栈''(存放着我们的变量等), 初始状态
就是``main的第一条语句'', 迁移就是``执行一条简单语句''. 因为任何一个C程序都可以
写成一个非复合语句的C代码, 并且的确有\href{https://cil-project.github.io/cil/}{这样的工具}和\href{https://gitlab.com/zsaleeba/picoc}{解释器}! 

这样的过程会对我们的调试代码带来好处. 比如, 我们可以使用\cw{gdb}来检查我们
感兴趣的输出, 同时我们可以使用\cw{printf}指令向我们输出感兴趣的调试信息. 

\subsection*{闲聊与练习} 

\begin{quote}
    孫子曰：凡治眾如治寡，分數是也。鬥眾如鬥寡，形名是也。三軍之眾，可使必受敵而無敗者，奇正是也。兵之所加，如以碬投卵者，虛實是也。

    Sunzi said: The control of a large force is the same principle as
    the control of a few men: it is merely a question of dividing up
    their numbers. Fighting with a large army under your command is 
    nowise different from fighting with a small one: it is merely a 
    question of instituting signs and signals. To ensure that your 
    whole host may withstand the brunt of the enemy's attack and 
    remain unshaken - this is effected by maneuvers direct and 
    indirect. That the impact of your army may be like a grindstone 
    dashed against an egg - this is effected by the science of weak 
    points and strong.
    
    \hfill ---  《孫子兵法·兵勢》
\end{quote}

\begin{exercise}{翻炒煎饼: 选自\cite{algobook}第一章问题4}
假设你得到一堆$n$个不同大小的煎饼。你想把薄煎饼排个序，这样小煎饼就在大煎饼的上
面。你唯一能做的就是翻转——在顶部的$k(k=1,2,\cdots, n)$个煎饼下面插入一把刀然后将它们全部翻转。
\incfig{recursion/pancake.png}
(1) 描述一种算法，使用尽可能少的翻转对一堆任意的$n$个煎饼进行排序。在最坏的情况下，你的算法到底执行了多少次翻转？

(2) 现在假设每个煎饼的一面都烧焦了。描述一种算法，对任意堆叠的$n$个煎饼进行排序，使每个煎饼烧焦的一面朝下，同样保证翻转次数尽可能少。在最坏的情况下，你的算法到底执行了多少次翻转？

(3) 使用你刚刚思考的结果, 完成\ti{UVA120 Stacks of Flapjacks}. 
\end{exercise}

\begin{exercise}{图像旋转: 选自\cite{algobook}第一章问题9}
假设我们想要将一个 $n \times n$ 的像素地图顺时针旋转 $90^\circ$($n$是2的
若干次幂)。一种方法是将像素地图分成四个 $\frac{n}{2} \times \frac{n}{2}$ 
的块，使用五次块传送将每个块移动到其正确的位置，然后递归地旋转每个块。
（为什么是五次？和汉诺塔问题需要第三个柱子的原因一样。）
另一种方法是首先递归地旋转块，然后将它们放到正确的位置。

\incfig{recursion/rotate.png}

\end{exercise}

\begin{exercise}{k-d树: 选自\cite{algobook}第一章问题25}
    假设我们有 $n$ 个散布在二维的盒子内的点。``k-d树''通过将这些点划分用递归的方
    式如下：首先，我们使用一条垂直的线将盒子分成两个较小的盒子，然后使用水平线将每个较小的盒子再次划分，如此反复进行，始终在水平和垂直划分之间交替。每次划分盒子时，划分线会通过盒子内的一个中位点(不在边界上)尽可能均匀地划分剩余的内部点。如果一个盒子不包含任何点，我们就不再继续划分它；这些最终为空的盒子称为单元(cells)。

    (1) 最后由多少个单元? 用$n$表示.  

    (2) 在最坏的情况下，一条水平线到底能穿过多少个单元？用$n$表示. 
\end{exercise}
\part{一些有趣的思想}

\section{二分法}

我们在解决问题的时候, 常常采用一些有趣的方法来进行. 比如, 我们有逻辑推理能力, 
来解答各种各样的问题. 我们先来考虑二分法. 

我们先考虑这样的一个猜数字游戏: 假设有一个人选定了一个秘密数字, 并让你来猜这个数字是多少.
这个秘密数字是在一个已知范围内的整数. 你可以每次猜一个数字, 然后得到一个提示: 告诉你
该数字是猜测的秘密数字的偏大还是偏小, 或者是猜中了. 
基于这个提示, 你要做的是继续猜测直到猜中为止. 你的目标是用最少的猜测次数找到秘密数字。

在上面的问题中, 我们可以找到某个性质的边界, 其中分别是小于这个数的和大于等于
这个数的. 也就是说, 我们要二分一个问题, 就是看一看这个边界是不是能够找到. 

在这一部分中, 我们首先会叙述这个的一般原理, 然后观察几个基本的问题以及几个
写代码的范式 - 很多时候写二分有关的代码是很容易犯错的. 结果就是无尽地死循环.
但是幸运的是, 我们可以避免这件事情发生. 

\subsection{基本的例子}

\lec{整数二分}{原理} 我们的目标是找一个性质的边界. 例如, 我们有如下的边界: 
并且有一个命题$P$, 左边的红色的部分是不满足$P$的, 右边的是满足$P$的. 

那么, 要找到红色的最右边的那个, 就(1)首先要找到一个中间值\codeword{mid=(l+r+1)>>1}
, (2)判断中间值是不是满足性质$P$, 也就是\codeword{check(mid)}. (2.1)如果$P$满足, 
那么\codeword{l=mid}; (2.2)如果$P$不满足, 那么\codeword{r=mid-1}. 返回
到(1), 重复执行, 直到\codeword{r>=l}. 

如果要找到绿颜色最左边的那一个, 和上面的问题相仿, 还是
(1)首先要找到一个中间值\codeword{mid=(l+r)>>1}
, (2)判断中间值是不是满足性质$P$, 也就是\codeword{check(mid)}. (2.1)如果$P$满足, 
那么\codeword{l=mid}; (2.2)如果$P$不满足, 那么\codeword{r=mid+1}. 返回
到(1), 重复执行, 直到\codeword{r>=l}. 

我们发现上述只是在取\codeword{mid}的时候和修改\codeword{l, r}的时候发生了
一点小问题. 这是因为C中的数组的舍去问题. 如果不这样做, 有时候会发生死循环 - 就是说
在锁定只有两个的时候, 不额外加一的时候, 可能会导致$l$在执行$(l+r)/2$之后还是$l$
. 这样就相当于什么都没有更新. 肯定不是我们想要的. 

\subsection{更多的例子}

\ti{P1163 银行贷款} 个人认为这个题面似乎有点表述不清. 我们采用另一个更严谨
的题目: 给出$n,m,k$, 求贷款者向银行支付的利率$p$, 使得: 
$$
n={m\over 1+p} +{m\over (1+p)^2}+{m\over (1+p)^3}+\cdots + {m\over (1+p)^k} 
$$
其中$p$保留0.1\%.  \mn{果然使用数学公式是很容易表达的}

Idea1. 我们来``猜测''$p$, 然后根据我们的猜测根据公式计算, 看一看它到底还的
多还是还的少. 如果多了, 就稍微把$p$往下调一点, 少了就把$p$往上调一点. 不过这道题
也有够坑的 -- 有的利率答案居然高达300\%! 所以二分的边界需要设置为300\%才行. 
我这里只让它执行了10000次二分操作 -- 毕竟最后的精度不高. \file{P1163}

\begin{remark}
    注意保留精度! 使用pow进行求和可能会扩大误差, 达到最后会差大约
    200元. 
\end{remark}

Idea2. 如果学习过了一些数学, 这个问题还可以使用数学的方法推演. 形如这样的
叫做等比数列, 意思是后一项除以前一项, 结果总是一个常数. 大家耳熟能详的
2, 4, 8, 16, 32, $\dots$ 这一串数列就是一个典型的等比数列, 其中
通向是$2^n$. 其中$n$是第几项(从1开始编号). 也就是说, 我要想知道第二项
是多少, 就要带入$n=2$, 结果就是$2^2=4.$ 

\lec{等比数列}{求和} 等比数列如何求和? 这就需要一些技巧: 我们假设等比
数列的通项是$a[n]=a_1q^{n-1}$, 
那么$S_n=a_1 + a_2q + a_3 q^2 +\cdots +a_n q^{n-1}$. 

我们发现这里面有很多的东西, 所以我们得想个办法把它们消掉. 采取两边同乘以
$q$, 两式相减, 就有神奇的效果. 这个方法也叫做错位相减法. 

TBD:公式推导

好了, 经过上面的推导, 我们就可以得到等比数列的求和: TBD

但是我们发现这个东西并不好解答... 确实, 我们并不能一味地通过一种方法解答
问题. 当我们遇到困难的时候就要多换角度. 

\ti{P2249 查找} 这个就是最基本的内容了. 直接参考代码就可以了! 注意刚刚
说过的一个问题: 到底是左端点还是右端点. 

\begin{remark}
    整数相关的二分的算法bug是比较隐蔽的. Java标准库中一个类似的查找函数
    使用了类似的二分方法. 但是它使用了\codeword{int mid = (low+high)/2;}
    导致了问题. 这个Bug在Java的数组标准库里面待了9年. 
    \href{https://dev.to/matheusgomes062/a-bug-was-found-in-java-after-almost-9-years-of-hiding-2d4k}{这里是原始文章.}
\end{remark}

\ti{P1676 Aggressive Cows G} 这个是最小值最大的问题, 意味着我们一般使用
按照答案二分的策略. 我们首先猜一个答案, 然后去施展我们应该有的构造, 最后
来看一看这个是不是太小了. 

我们可以假设牛棚都是空的, \codeword{check}时如果当前牛棚与上一个住上牛的牛棚之间
的距离\codeword{dis>=mid}, 我们就可以让这个牛棚里住上牛, 反之向更远的距离寻找牛
棚. 这是个贪心算法. 如果最后能安排的牛总数小于总的牛数, 那么就可以扩大需求. 
(\codeword{r=mid}) 
反之, 就要缩小(\codeword{l=mid+1}). 

\begin{ques}
    为什么这个贪心算法是对的? 
\end{ques}

我们说: 按照上面的构造, 一定是``最省''的. 并且我们只要能说明只要不按照这样做
不一定是最省的就可以了. 也就是, 最小值可能会变得更小. 

\ti{P2678 跳石头}  这个仍然是最小值最大的问题. 和上一个问题是类似的. 自己试着
感受一下吧!

\ti{P3853 路标设置} 这个和上面的问题也是一样的. 自己动手试一试吧! 

\ti{P1314 聪明的质检员} 这个虽然标号的颜色是绿色的, 但是仍然逃不过二分答案的
区间. 不过, 这里面可能有些符号难以阅读. 我们来简单阅读一下: 

\lec{求和符号}{简介} 求和记号是一大堆连加记号的缩写. 简单来说, 只是一个省略
而已, 并没有万能的公式可以求和任何事情. 

\lec{Iverson的括号}{简介} Iverson记号写作$[..]$其中, 里面的$..$是一个
布尔表达式. 当里面的结果是真的时候, 值为1, 否则值为0. 

Iverson括号可以和求和一起搭配使用, 来达到简化求和记号的作用. 比如, 我们要交换
两个求和记号的时候, 更好的想法可能是用这样的方法: TBD 

介绍了刚刚的内容, 我们来简单梳理一下这个问题. 

我们要得到$\min |s-y|$, 就必须找到合适的$W$, 进而得到对应的$y$. 并且另一个
观察是: $y$ 越大, $W$越小. 当$y<s$时, $y$偏小, 我们就要减小$W$; 当$y=s$的
时候, 我们就得到了我们想要的结果. 当$y>s$时, $y$偏小, 我们就要增大$W$. 

我们求$y$的过程满足单调性, 因此使用二分的方法即可. 到这里, 我们能够得到70分. 
查询的部分有个双重的for循环. 这部分使用前缀和优化一下就好. 我们马上会提及. 

\section{前缀和与差分}

\lec{前缀和}{普通版本}现在有一个数组, 请问$\sum_{i=l}^r a_i$等于多少? 我们很容易用for循环实现. 
但是, 如果这样的事情会发生多达$10^5$, 应该怎么办? 一个好的想法是我们可以把
他们累加起来. 

\begin{definition}
    如果一个数组$a$, 它的前缀和数组$s$的通项为$s_i = a_1 + \cdots + a_i$. 
\end{definition}

这时候要想求$l\sim r$的和就求$s_r - s_l$即可. 

\begin{ques}
    既然有前缀和, 那么你认为什么操作下积可以被前缀吗? 你觉得能够前缀的问题
    有哪些特征?  
\end{ques}

我们发现上述的前缀和问题能够胜任查询问题, 但是对于修改操作并没有办法很好的胜任
因为单点进行修改之后, 其之后的前缀和都要发生变化. 

\lec{前缀和}{何必要前缀``和''?}事实上, 前缀和刻画了``连续进行若干次操作, 产生的一个综合影响可以通过某种手段
撤销. '' 比如, 我们如果连着加他们, 到最后可以使用减法把影响的区间消除. 
减法在数学中称为加法的``逆(inverse)运算''. 普通乘法的逆运算是除法. 

事实上, 运算这件事情可以被定义得很广泛. 比如, 你可以在正方形纸片上面定义一个
运算, 叫做``向右旋转90度''. 它的逆运算可以是``向左旋转90度'', 或者说
``连续做3次向右旋转90度''. 

下面我们来看一个比较奇怪的, 但是也能用上述的思想做的内容. 

\begin{example}
    现在有编号为$0\sim 10$一共$10$个球, 我们现在有若干个区间的对换. 具体地, 
    对于区间$[l..r]$的对换之后, 如果原来这方面的球的编号是
    $\cdots, a_l, a_{l+1}, \cdots, a_r, \cdots$, 那
    么经过这次对换之后, 这个区间的球
    的顺序就变成了
    $\cdots, a_{l+1}, a_{l+2}, \cdots , a_r, a_l,\cdots $. 

    现在你有$n$条操作规则, 每条操作规则就是两个数$l,r$. 现在, 我们想知道
    你连续执行编号$a$到编号$b$的操作规则之后, 得到的内容是多少. 注意有$m$次
    查询. 

    数据范围: $1\leq n, m \leq 10^5, 0\leq a, b\leq 9, 1\leq l\leq r\leq n.$
\end{example}

我们如果这时候把``交换''当做一个运算, 运算的``数''就是你现在交换的
区间左端点和右端点, 这样子就和刚刚加法减法的前缀和类似了. 事实上, 这样的
对换在后续学习中是很重要的. 

\begin{remark}
    重要的对换: 如果你之后学习了Polya定理, 其中有一个重要的结论是任何一个置换都可以分解成
    若干个对换的复合. 这会对于你计数带有对称性的内容带来很大的帮助. 
    
    另外, 在数学中, 抽象代数中的群也有类似的刻画. 同样也有更加一般化的结论
    和内容. 不过要是学习这个, 必须有足够扎实的数学基础和对于许多内容的熟练
    掌握(如数学分析, 高等代数等基础课程)
    在这里我们不做讨论. 
\end{remark}

当然, 上述的内容只是一个简单的例子. 当你学习了更多的结构的时候, 很多结构
天然地满足这个性质. 到时候请多加留意. 

\lec{差分}{普通版本} 我们发现, 前缀和让我们拥有在$\mathcal O(1)$时间查询的
能力. 但是如果修改起来可能就麻烦了. 这里, 我们介绍一种方法, 使得我们可以在
$\mathcal O(1)$时间内修改, 并且能够$\mathcal O(n)$查询出来单点的值. 

我们现在的问题是有一个数组$a$, 每一次, 我要向$l..r$的区间内的元素加上一个
值$d$. 最后只有一次询问, 问我现在第几个元素被改成几了. 这样的修改会发生很多
次, 因此我们不能使用for循环来做. 

我们发现, 在对于区间一整个加的操作中, 我们在这一个区间加和的过程中, 区间
内部的两个数之间的\textbf{差}一直不变. 于是我们试着引入差分的定义: 

\begin{definition}
    对于一个数组$a$, 我们定义$d_i=a_i-a_{i-1}$, 那么$d$数组为原数组
    的差分(difference)数组. 
\end{definition}

TBD: 具体的操作: 一个点$+x$, 另一个点$-x$就可以. 详细描述之

挺有趣: 刚刚使用了累加, 我们才能得到了一个可以胜任区间求和, 但是做不了区间
修改的东西. 现在我们让每一个内容是它减去它前面的内容, 居然可以胜任修改, 
但是无法胜任区间的求和. 

那么, 我们的原数组$d$, 这个数组$a$, 以及前缀和数组之间$s$有什么关系呢? 
经过不复杂的数学推导, 我们可以发现: 

TBD 插入一个他们之间关系的图

\begin{remark}
    这个关系, 在你上了高中, 接触到了路程, 速度, 加速度的关系的时候, 
    会发现它们是出奇的一致的. 为什么? 路程, 速度, 加速度的关系就似乎
    是这里的$x, v,a$的关系. 完整的知识在大学才能揭晓 -- 那时候
    你会学习数学分析, 更进一步地看一看在连续的情形下, 我们是如何做
    ``前缀和''的. 
\end{remark}

\lec{差分}{加一个等差数列?} 如果我们要在之间加一个等差数列, 那该怎么办?
比如原数列是$1,2,3,4,5$, 在区间$[1..3]$加上等差数列$2, 4, 6$, 最后
的结果是$3, 6, 9, 4, 5$. 

我们发现, 我们让原来的差分数组再差分一次不就好了! 等差数列再次差分, 就只要
在前面加一个数, 在后面减掉一个数了, 就像刚才一样. 这是差分的一个重要的性质.

在练习中, 你会看到有哪些差分做起来是好做的. 你同时也会发现很多奇妙的公式. 

\lec{差分}{加一个平方数列?} 这次我们使劲差分, 差分到三次, 你就会发现, 他们
就会奇迹般地出现出来0的样式了. 

\begin{ques}
    为什么是差分三次?
\end{ques}

事实上, 我们会发现每次差分之后, 得到的内容就会消掉一次. 也就是从二次变到
一次, 再到0次. 在0次的情形, 就是我们最开心的情况了. 如果下次要加上一些单项式
的组合, 其实同样的方法也是适用的. 

\lec{前缀和}{多次前缀和} TBD: 阐述数列$1,1,1,1,1...$和杨辉三角, 组合数的联系.

\lec{前缀和}{二维的前缀和} TBD: 阐述二维前缀和的内容. 并且给出基本的例子
简单介绍容斥原理, 为后续做准备. 

\section{贪心算法}

TBD: 讲解贪心的基本例子以及常用的正确性证明的方法. 回顾区间相关的问题

\section{倍增}

TBD: 展示倍增是应对有结合律的内容的一个加速的方法.

\section{更多的练习与思考}

TBD: 构造答案, 问题分解, 带有顺序的枚举法, 滑动窗口

\section{并查集简介: 指来指去}

TBD: 介绍并查集的一些有趣的操作. 并且提示一个有名的话语: 
计算机科学中的问题大部分可以加一层抽象层解决, 不能的那些
就是加了太多的抽象层. 
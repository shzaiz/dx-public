\part{一些有趣的思想}

计算机也许是快的, 但不是无限快的. 内存空间可能是廉价的, 但不是免费的. 
所以, 无论是时间还是空间, 都是有限的资源. 我们必须用一些有趣的思想, 聪明地
抉择使用时间或者空间. 

\section{二分法}

我们先考虑这样的一个猜数字游戏: 假设有一个人选定了一个秘密数字, 并让你来猜这个数字是多少.
这个秘密数字是在一个已知范围内的整数. 你可以每次猜一个数字, 然后得到一个提示: 告诉你
该数字是猜测的秘密数字的偏大还是偏小, 或者是猜中了. 
根据这个提示, 你要做的是继续猜测直到猜中为止. 你的目标是用最少的猜测次数找到秘密数字. 

在上面的问题中, 我们可以找到某个性质的边界, 其中分别是小于这个数的和大于等于
这个数的. 也就是说, 我们要二分一个问题, 就是看一看这个边界是不是能够找到. 

在这一部分中, 我们首先会叙述这个的一般原理, 然后观察几个基本的问题以及几个
写代码的范式 - 很多时候写二分有关的代码是很容易犯错的. 结果就是无尽地死循环.
但是幸运的是, 我们可以避免这件事情发生. 


\lec{整数二分}{原理} 我们的目标是找一个性质的边界. 例如, 我们有如下的边界: 
并且有一个命题$P$, 左边的红色的部分是不满足$P$的, 右边的是满足$P$的. 

\incfig{opt-search/bsearch.png}

那么, 要找到红色的最右边的那个, 就(1)首先要找到一个中间值\codeword{mid=(l+r+1)>>1}
, (2)判断中间值是不是满足性质$P$, 也就是\codeword{check(mid)}. (2.1)如果$P$满足, 
那么\codeword{l=mid}; (2.2)如果$P$不满足, 那么\codeword{r=mid-1}. 返回
到(1), 重复执行, 直到\codeword{r>=l}. 

如果要找到绿颜色最左边的那一个, 和上面的问题相仿, 还是
(1)首先要找到一个中间值\codeword{mid=(l+r)>>1}
, (2)判断中间值是不是满足性质$P$, 也就是\codeword{check(mid)}. (2.1)如果$P$满足, 
那么\codeword{l=mid}; (2.2)如果$P$不满足, 那么\codeword{r=mid+1}. 返回
到(1), 重复执行, 直到\codeword{r>=l}. 

我们发现上述只是在取\codeword{mid}的时候和修改\codeword{l, r}的时候发生了
一点小问题. 这是因为C中的数组的舍去问题. 如果不这样做, 有时候会发生死循环 - 就是说
在锁定只有两个的时候, 不额外加一的时候, 可能会导致$l$在执行$(l+r)/2$之后还是$l$
. 这样就相当于什么都没有更新. 肯定不是我们想要的. 

\lec{实数范围的二分}{原理} 如果我们希望在实数范围上面二分, 就没有那个恼人的
``边界情况(corner case)''了. 我们一般有两种办法. 其一是让它二分执行某一个很大的次数
(例如1000次); 另一种是看一看当前是否达到了精度. 

\lec{练习}{更多的例子}\ti{P1163 银行贷款} 个人认为这个题面似乎有点表述不清. 我们采用另一个更严谨
的题目: 给出$n,m,k$, 求贷款者向银行支付的利率$p$, 使得: 
$$
n={m\over 1+p} +{m\over (1+p)^2}+{m\over (1+p)^3}+\cdots + {m\over (1+p)^k} 
$$
其中$p$保留0.1\%.  \mn{果然使用数学公式是很容易表达的}

Idea1. 我们来``猜测''$p$, 然后根据我们的猜测根据公式计算, 看一看它到底还的
多还是还的少. 如果多了, 就稍微把$p$往下调一点, 少了就把$p$往上调一点. 不过这道题
也有够坑的 -- 有的利率答案居然高达300\%! 所以二分的边界需要设置为300\%才行. 
我这里只让它执行了10000次二分操作 -- 毕竟最后的精度不高. \file{P1163}

\begin{remark}
    注意保留精度! 使用pow进行求和可能会扩大误差, 达到最后会差大约
    200元. 
\end{remark}

Idea2. 如果学习过了一些数学, 这个问题还可以使用数学的方法推演. 形如这样的
叫做等比数列, 意思是后一项除以前一项, 结果总是一个常数. 大家耳熟能详的
2, 4, 8, 16, 32, $\dots$ 这一串数列就是一个典型的等比数列, 其中
通向是$2^n$. 其中$n$是第几项(从1开始编号). 也就是说, 我要想知道第二项
是多少, 就要带入$n=2$, 结果就是$2^2=4.$ 

\lec{等比数列}{求和} 等比数列如何求和? 这就需要一些技巧: 我们假设等比
数列的通项是$a[n]=a_1q^{n-1}$, 
那么$S_n=a_1 + a_2q + a_3 q^2 +\cdots +a_n q^{n-1}$. 

我们发现这里面有很多的东西, 所以我们得想个办法把它们消掉. 采取两边同乘以
$q$, 两式相减, 就有神奇的效果. 这个方法也叫做错位相减法. 

推导过程如下所示: 
\begin{example}
    假设我们有一个等比数列: \(a, ar, ar^2, ar^3, \ldots, ar^{n-1}\) , 其中 \(a\) 是首项,  \(r\) 是公比,  \(n\) 是项数. 

我们想要求这个等比数列的和, 表示为 \(S_n\). 
首先, 我们将数列的前 \(n\) 项相加: 
\[ S_n = a + ar + ar^2 + ar^3 + \ldots + ar^{n-1} \]
接下来, 我们将 \(S_n\) 乘以公比 \(r\): 
\[ rS_n = ar + ar^2 + ar^3 + \ldots + ar^{n-1} + ar^n \]
接下来, 我们从 \(rS_n\) 中减去 \(S_n\): 
\[ rS_n - S_n = (ar + ar^2 + ar^3 + \ldots + ar^{n-1} + ar^n) - (a + ar + ar^2 + ar^3 + \ldots + ar^{n-1}) \]
注意, 在括号内的部分可以通过消去相同项来简化. 我们得到: 
\[ rS_n - S_n = ar^n - a \]
接下来, 将 \(S_n\) 提取出来: 
\[ S_n(r - 1) = ar^n - a \]
现在, 将 \(S_n\) 解出来: 
\[ S_n = \frac{ar^n - a}{r - 1} \]
这就是等比数列的求和公式. 
如果公比 \(r = 1\), 那么这个等比数列就变成了等差数列, 求和公式变为: 
\[ S_n = \frac{n}{2}(a + l) \]
其中,  \(l\) 是数列的最后一项. 
\end{example}

好了, 经过上面的推导, 我们就可以得到等比数列的求和: $S_n=\frac{a_1(1-q^n)}{1-q}$.


但是我们发现这个东西并不好解答... 确实, 我们并不能一味地通过一种方法解答
问题. 当我们遇到困难的时候就要多换角度. 

\ti{P2249 查找} 这个就是最基本的内容了. 直接参考代码就可以了! 注意刚刚
说过的一个问题: 到底是左端点还是右端点. \file{P2249}\mn{
    整数相关的二分的算法bug是比较隐蔽的. Java标准库中一个类似的查找函数
    使用了类似的二分方法. 但是很不幸这段代码写错了. 
    这个Bug在Java的数组标准库里面待了9年. 
    \href{https://dev.to/matheusgomes062/a-bug-was-found-in-java-after-almost-9-years-of-hiding-2d4k}{这里是原始文章.}}


\ti{P1676 Aggressive Cows G} 这个是最小值最大的问题, 意味着我们一般使用
按照答案二分的策略. 我们首先猜一个答案, 然后去施展我们应该有的构造, 最后
来看一看这个是不是太小了. 

我们可以假设牛棚都是空的, \codeword{check}时如果当前牛棚与上一个住上牛的牛棚之间
的距离\codeword{dis>=mid}, 我们就可以让这个牛棚里住上牛, 反之向更远的距离寻找牛
棚. 这是个贪心算法. 如果最后能安排的牛总数小于总的牛数, 那么就可以扩大需求. 
(\codeword{r=mid}) 
反之, 就要缩小(\codeword{l=mid+1}). 

\begin{ques}
    为什么这个贪心算法是对的? 
\end{ques}

我们说: 按照上面的构造, 一定是``最省''的. 并且我们只要能说明只要不按照这样做
不一定是最省的就可以了. 也就是, 最小值可能会变得更小. 

\ti{P2678 跳石头}  这个仍然是最小值最大的问题. 和上一个问题是类似的. 自己试着
感受一下吧! \file{P2678}

\ti{P3853 路标设置} 这个和上面的问题也是一样的. 自己动手试一试吧!  \file{P3853}

\ti{P1314 聪明的质检员} 这个虽然标号的颜色是绿色的, 但是仍然逃不过二分答案的
区间. 不过, 这里面可能有些符号难以阅读. 我们来简单阅读一下: 

\lec{求和符号}{简介} 求和记号是一大堆连加记号的缩写. 简单来说, 只是一个省略
而已, 并没有万能的公式可以求和任何事情. 

\lec{Iverson的括号}{简介} Iverson记号写作$[..]$其中, 里面的$..$是一个
布尔表达式. 当里面的结果是真的时候, 值为1, 否则值为0. 

Iverson括号可以和求和一起搭配使用, 来达到简化求和记号的作用. 比如, 我们要交换
两个求和记号的时候, 更好的想法可能是用这样的方法\mn{更多的内容可以参看
\cite{knuth1989concrete}2.4节 多重和式(MULTIPLE SUMS)}: 
$$
[1\leq j\leq n][j\leq k \leq n]=[1\leq j \leq k \leq n] = 
[1\leq k\leq n][1\leq j\leq k]. 
$$

介绍了刚刚的内容, 我们来简单梳理一下这个问题. 

我们要得到$\min |s-y|$, 就必须找到合适的$W$, 进而得到对应的$y$. 并且另一个
观察是: $y$ 越大, $W$越小. 当$y<s$时, $y$偏小, 我们就要减小$W$; 当$y=s$的
时候, 我们就得到了我们想要的结果. 当$y>s$时, $y$偏小, 我们就要增大$W$. 

我们求$y$的过程满足单调性, 因此使用二分的方法即可. 到这里, 我们能够得到部分分. 
查询的部分有个双重的for循环. 这部分使用前缀和优化一下就好. 我们马上会提及. \file{P1314-partial}

\subsection*{闲聊与练习}

\begin{exercise}{二分的一些练习问题}
    可以实现以下的练习题: 
    
    (1) P1182 数列分段 Section II

    (2) P1873 [COCI2011-2012] EKO / 砍树    
\end{exercise}

\begin{exercise}{三分法}
    我们来看题目\ti{P3382 三分法}.

    三分法的基本的用途是求单峰函数的极值点. 我们以求函数的极大值为例, 可以每次对一个区间$[l,r]$求三等分点\cw{lsec}和\cw{rsec}, 
    \begin{itemize}[noitemsep]
        \item 如果$f(\texttt{lsec}) < f(\texttt{rsec})$ , 说明极大值一定在$[\texttt{lsec},r]$内取到, 因为如果在$[0,\texttt{lsec})$内, 那\texttt{rsec}一定处于单调下降的区间内, 它的函数值不可能大于lsec的函数值. 于是就可以令$l=\texttt{lsec}$并继续. 
        \item 如果$f(\texttt{lsec})$ > $f(\texttt{rsec})$, 同理, 极大值一定在$[l,\texttt{rsec}]$内取到, 令$r=\texttt{rsec}$并继续. 
        \item 可以重复上面的两个步骤, 直到小于给定的精度. 
    \end{itemize}

    本问题的题解里面有很多同学说使用求导之后二分函数的零点就可以了. 那么什么是求导? 
    我们可以欣赏3Blue1Brown带来的\href{https://www.bilibili.com/video/BV1qW411N7FU}{《微积分的本质》}系列视频. 请注意, 这类视频只是提供了一个最基本的
    介绍, 并没有做非常严格的讨论(因为做出严格的讨论大家初学的时候就看不懂了). 
    所以, \textbf{请不要做名词党.}\mn{发现一个现象就是一些资历尚浅的学生(主要指我自己)有时会通过B站/知乎等互联网媒介去不加区分的接受知识和观点, 而又由于学识不足容易囫囵吞枣牵强附会, 从而走向了名词党的道路. 与此同时, 因为互联网大家更容易看到各种大神的发展路径, 不加辨别的让自己和他们比较也只会给自己徒增压力. (一段数心写的, 我自己很认同的自我反思)}
    
\end{exercise}




\section{前缀和与差分}

\lec{前缀和}{普通版本}现在有一个数组, 请问$\sum_{i=l}^r a_i$等于多少? 我们很容易用for循环实现. 
但是, 如果这样的事情会发生多达$10^5$, 应该怎么办? 一个好的想法是我们可以把
他们累加起来. 

\begin{definition}
    一个数组$a$, 它的前缀和数组$s$的通项为$s_i = a_1 + \cdots + a_i$. 
\end{definition}

这时候要想求$l\sim r$的和就求$s_r - s_l$即可. 

\begin{ques}
    既然有前缀和, 那么你认为什么操作下积可以被前缀吗? 你觉得能够前缀的问题
    有哪些特征?  
\end{ques}

我们发现上述的前缀和问题能够胜任查询问题, 但是对于修改操作并没有办法很好的胜任
因为单点进行修改之后, 其之后的前缀和都要发生变化. 

\lec{前缀和}{何必要前缀``和''?}事实上, 前缀和刻画了``连续进行若干次操作, 产生的一个综合影响可以通过某种手段
撤销. '' 比如, 我们如果连着加他们, 到最后可以使用减法把影响的区间消除. 
减法在数学中称为加法的``逆(inverse)运算''. 普通乘法的逆运算是除法. 

事实上, 运算这件事情可以被定义得很广泛. 比如, 你可以在正方形纸片上面定义一个
运算, 叫做``向右旋转90度''. 它的逆运算可以是``向左旋转90度'', 或者说
``连续做3次向右旋转90度''. 

下面我们来看一个比较奇怪的, 但是也能用上述的思想做的内容. 

\begin{example}
    现在有编号为$0\sim 10$一共$10$个球, 我们现在有若干个区间的对换. 具体地, 
    对于区间$[l..r]$的对换之后, 如果原来这方面的球的编号是
    $\cdots, a_l, a_{l+1}, \cdots, a_r, \cdots$, 那
    么经过这次对换之后, 这个区间的球
    的顺序就变成了
    $\cdots, a_{l+1}, a_{l+2}, \cdots , a_r, a_l,\cdots $. 

    现在你有$n$条操作规则, 每条操作规则就是两个数$l,r$. 现在, 我们想知道
    你连续执行编号$a$到编号$b$的操作规则之后, 得到的内容是多少. 注意有$m$次
    查询. 

    数据范围: $1\leq n, m \leq 10^5, 0\leq a, b\leq 9, 1\leq l\leq r\leq n.$
    \file{extra-prob}
\end{example}

我们如果这时候把``交换''当做一个运算, 运算的``数''就是你现在交换的
区间左端点和右端点, 这样子就和刚刚加法减法的前缀和类似了. 事实上, 这样的
对换在后续学习中是很重要的. 

\begin{remark}
    重要的对换: 如果你之后学习了Polya定理, 其中有一个重要的结论是任何一个置换都可以分解成
    若干个对换的复合. 这会对于你计数带有对称性的内容带来很大的帮助. 
    
    另外, 在数学中, 抽象代数中的群也有类似的刻画. 同样也有更加一般化的结论
    和内容. 不过要是学习这个, 必须有足够扎实的数学基础和对于许多内容的熟练
    掌握(如数学分析, 高等代数等基础课程)
    在这里我们不做讨论. 
\end{remark}

当然, 上述的内容只是一个简单的例子. 当你学习了更多的结构的时候, 很多结构
天然地满足这个性质. 到时候请多加留意. 

\lec{差分}{普通版本} 我们发现, 前缀和让我们拥有在$\mathcal O(1)$时间查询的
能力. 但是如果修改起来可能就麻烦了. 这里, 我们介绍一种方法, 使得我们可以在
$\mathcal O(1)$时间内修改, 并且能够$\mathcal O(n)$查询出来单点的值. 

我们现在的问题是有一个数组$a$, 每一次, 我要向$l..r$的区间内的元素加上一个
值$d$. 最后只有一次询问, 问我现在第几个元素被改成几了. 这样的修改会发生很多
次, 因此我们不能使用for循环来做. 

我们发现, 在对于区间一整个加的操作中, 我们在这一个区间加和的过程中, 区间
内部的两个数之间的\textbf{差}一直不变. 于是我们试着引入差分的定义: 

\begin{definition}
    对于一个数组$a$, 我们定义$d_i=a_i-a_{i-1}$, 那么$d$数组为原数组
    的差分(difference)数组. 
\end{definition}

我们发现, 如果要在原数组的$[l..r]$上加上一个数$x$, 只要在$d_l$上加上$x$, 
在$d_r$上减去$x$. 

挺有趣: 刚刚使用了累加, 我们才能得到了一个可以胜任区间求和, 但是做不了区间
修改的东西. 现在我们让每一个内容是它减去它前面的内容, 居然可以胜任修改, 
但是无法胜任区间的求和. 

那么, 我们的原数组$d$, 这个数组$a$, 以及前缀和数组之间$s$有什么关系呢? 
经过不复杂的数学推导, 我们可以发现: 

\incfig{opt-search/relation.png}

\begin{remark}
    这个关系, 在你上了高中, 接触到了路程, 速度, 加速度的关系的时候, 
    会发现它们是出奇的一致的. 为什么? 路程, 速度, 加速度的关系就似乎
    是这里的$x, v,a$的关系. 完整的知识在大学才能揭晓 -- 那时候
    你会学习数学分析, 更进一步地看一看在连续的情形下, 我们是如何做
    ``前缀和''的. 
\end{remark}

\lec{差分}{加一个等差数列?} 如果我们要在之间加一个等差数列, 那该怎么办?
比如原数列是$1,2,3,4,5$, 在区间$[1..3]$加上等差数列$2, 4, 6$, 最后
的结果是$3, 6, 9, 4, 5$. 

我们发现, 我们让原来的差分数组再差分一次不就好了! 等差数列再次差分, 就只要
在前面加一个数, 在后面减掉一个数了, 就像刚才一样. 这是差分的一个重要的性质.

在练习中, 你会看到有哪些差分做起来是好做的. 你同时也会发现很多奇妙的公式. 

\lec{差分}{加一个平方数列?} 这次我们使劲差分, 差分到三次, 你就会发现, 他们
就会奇迹般地出现出来0的样式了. 

\begin{ques}
    为什么是差分三次?
\end{ques}

事实上, 我们会发现每次差分之后, 得到的内容就会消掉一次. 也就是从二次变到
一次, 再到0次. 在0次的情形, 就是我们最开心的情况了. 如果下次要加上一些单项式
的组合, 其实同样的方法也是适用的. 

\lec{前缀和}{二维的前缀和} 前缀和有另一个扩展的方向. 我们能不能扩展到二维的前缀
和? 我们可以这样做. 我们仿照一维前缀和的定义, 使用$S[i][j]$表示第$i$行$j$列格子左上部分所有元素的和. 那么它的递推式是什么? 
\incfig{opt-search/2d-prefix-sum.png}

于是, 我们就可以写出来二维前缀和的代码. \file{prefix-sum-2d}

\subsection*{闲聊与练习}

\begin{exercise}{二维差分}
    二维差分大概的思想就是选择一个矩形区域, 将区域内的所有元素增加或减少一个数. 
    但是二维差分的思维的还是有的.
    
    实际上, 这种由一维变到二维, 考虑难度陡然上升的例子是很常见的. 将来在学习高等数学
    类似的科目的时候, 可能会发现多元函数的考虑比一元函数繁杂很多. 
\end{exercise}

\begin{exercise}{聪明的质检员: 满分做法}
    请使用前缀和优化的方法优化我们以前要求的这个问题. 
\end{exercise}

\begin{exercise}{前缀和与差分的两个方向}
    前缀和和差分的发展方向有两个: 分别是多维的前缀和/差分或者多次进行前缀和/差分. 
    此外, 我们在树上维护一些属性的时候还可以再树上进行差分. 这种的问题还是需要
    见一些的. 请阅读树上差分的相关博客, 资料, 看一看树上差分和普通的差分有哪些
    相同之处. 

    简单来说, 点差分的情形是: 有$n$次修改操作, 每次把$u\to v$的所有点权加上$x$, 
    问最后的点最大值. 此外, 我们可能在边上维护一些信息. 如果有$n$次修改操作, 
    每次把$u\to v$的路径的权值加上$x$, 求$x\to y$的最大点值. 

    可以参考例题: \ti{P3128 [USACO15DEC] Max Flow P}~\ti{P3258 松鼠的新家}
    ~ \ti{\href{https://loj.ac/p/146}{DFS 序 3, 树上差分 1}}

\end{exercise}

\section{贪心算法}

贪心是指在最优化问题的决策过程中, 每次选择当前局面的最优决策. 不过需要指出的是, 
当前局面最优不一定能得到全局最优. 通常, 我们要使用贪心算法, 至少要思考一下如何
说明一下它的正确性. 

\begin{remark}
    有点有趣的是, 在推荐给大家的Jeff Erickson的Algorithm\cite{algobook}书中, 作者风趣地
    写道: ``Greedy algorithms never work! Use dynamic programming instead!''.

    这显示了使用贪心算法的副作用 -- 没有说明胡乱贪心有时候不可取. 其中的 
    Dymanic Programming是动态规划的意思, 现在可以认为是聪明的搜索 -- 使用
    记忆的方法避免求解了一些重复的子问题. 我们会在后面简单了解. 
\end{remark}

我们来看若干个问题: 

\ti{P1056 排座椅} 对于单独的某邻近两列, 如果有$x$对爱唠嗑的同学, 选择拆散这一列, 
就拆散了$x$对同学, 邻近两行也是同理的. 另外, 对于任意情况, 我们都应该拆散
邻近两列或两行爱唠嗑同学对数最多的那两行或两列. 不然, 我们本可以拆散更多的同学. 
我们刚刚的论证用了问题的描述以及反证法(``不然...''). 虽然思路很好想, 但是注意
输出的时候是按照编号输出的. \file{P1056}. 

\ti{P1016 旅行家的预算} 我们可以在油便宜的时候必须要买油, 只要比当前油价便宜就好. 
如果在油箱的油消耗完之前不能到达比当前油价还便宜的地方, 就在这里把油箱加满油. 
如果能到达比当前油价便宜的地方, 那就加油到刚好能跑到那个地方. \file{P1016}



不过要注意的是, 贪心可能很难, 贪心的结果也可能非常有趣. 我们下面来看一个有趣的
脑筋急转弯. 

\ti{\href{https://www.luogu.com.cn/problem/AT_arc066_c}{Addition and Substraction Hard}}
这个题目的意思很简单: 给你一个只包含`+'、`-'、正整数的式子, 你需要在式子中添加一些括号
, 使运算结果最大, 输出最大的结果. 

首先我们看到我们必须在减号的后面加括号. 因为减号的后面才能使得符号发生变化. 
在这个第一个括号里面, 我们就需要闭合的时候这个值尽可能的小了. 那么如何让这第一个
括号里面的值尽可能小呢? 首先, 这个第一个括号的闭合肯定在式子的最末尾. 
其次, 我们可能还要在减号的后面继续加括号, 但是要满足让原式的结果尽量大, 第二层括号
里面的值的要求是也是尽可能最大 -- 也就是让第二个括号里面的加号最多. 我们只需要把所有的
减号后面的连加符号都括起来即可. 

这就是我们的贪心思路了. 我们可能会说: 为什么不会有嵌套三层(往上)的情况? 其实, 我们 
注意到, 任何一个嵌套括号到了3层(或往上), 一般形态为$x_0-(x_1-(x_2-(x_3)))$其实
可以被组合成为$x_0-(x_1-x_2)-(x_3)$, 保留了原来的减号. 但是枚举每一个括号计算的
时间是$\mathcal O(n^2)$的, 难以应对数据量. 我们使用前, 后缀和的技巧来优化我们的
计算. 

要观察出这个思路需要相当对算术运算的体会. 官方给出的题解使用了动态规划的思路. 
正如我们刚刚
提到的, 这是一个``聪明地搜索状态空间''的算法. 我们可能会在未来重新回顾官方题解的做法.

\subsection*{闲聊与练习} 

\begin{exercise}{装载相关问题(选自紫书\cite{liu2014}~8.4节)}
    有$n$个人, 第$i$个人的重量为$w_i$, 每一艘船最大的重量均为$C$, 且只能乘坐两个人
    使用最少的船装所有的人. 描述贪心策略, 并说说为什么. 之后与原文对照. 

    注意这里原文中使用了大小关系的传递, 来证明我们的观点的. 同时, 我们使用了交换的方法
    . 这些方法是我们有时候比较常用的. 
\end{exercise}

\begin{exercise}{区间相关问题(选自紫书\cite{liu2014}~8.4节)}
    我们的要求如下: 

    (1) 选择不相交的区间: 数轴上有$n$个开区间$(a_i, b_i)$, 尽量选择多个区间, 使得
    区间两两不相交. 

    (2) 区间选点问题: 数轴上有$n$个闭区间$[a_i, b_i]$, 取尽量少的点, 使得每一个区间
    里面都有一个点. 

    (3) 区间覆盖问题: 数轴上有$n$个闭区间$[a_i, b_i]$, 尽量选择少的区间覆盖一条指定
    的线段$[s,t]$. 

    同样, 在想一想这些问题之后, 看一看紫书中对应的描述. 看一看有没有类似的感觉. 
\end{exercise}

\begin{exercise}{Huffman编码相关的问题(选自紫书\cite{liu2014}~8.4节)}
    阅读关于Huffman编码贪心的正确性证明. 试图感受恰当的数据结构在我们的证明问题
    中的作用. 
\end{exercise}

\section{倍增}

\lec{介绍}{引例1} 不知道大家有没有在无聊
\mn{没有无聊的时候? 相信我到时候一定会有的. 比如河南省的会考. 如果
当前情况维持不变的话, 会考理科的试题是非常充足的. 当时大概所有理科作答时间
(数学, 物理, 化学, 生物)加起来总共用了一个小时左右, 所以在那个时候就可以轻松
体会这个游戏了. }
的时候玩过算2的几次幂的游戏: $2^1=2, 2^2=4, 2^3=8, \cdots$. 许多同学在各种
评论区分享了他们算过的最大值. 但是, 我们发现, 我们可以这样来算得更多一些: 
$2\times 2=4, 4\times 4 = 16, 16\times 16=256, 256\times 256=65536\cdots$. 

如果记得\codeword{unsigned int}的最大值是$2^{32}-1$, 即$4294967295$, 那么你可能应该可以
很快地计算出$2^{64}$, 甚至$2^{128}$了. 为了好玩, 我们给出$2^{256}$这个78位数: 

$$
115792089237316195423570985008687907853269984665640564039457584007913129639936
$$

并且我们发现, 我们如果要任意的一个幂次, 就都可以用上面的一些内容表示出来. 比如, $2^3=2^2\times 2^1$.
因为$3=(101)_2$. 由此, 我们就可以发明``快速幂''的算法. 我们只要$\log_2 b$次来计算$a^b$(不溢出的情况下).

\ti{P1226 【模板】快速幂 | 取余运算} 这里只是多了一个取余数的运算. 我们发现
$(a\times b)\bmod c = ((a\bmod c)\times (b\bmod c))\bmod c$. 用这个内容写代码就好了. \file{qpow}


\lec{ST表}{介绍}  我们刚刚使用二进制去拼凑一个整数的方法能不能用于其他的问题呢? 其实, ``可重复贡献的问题''
就是我们可以用这样的方式做的. 我们可以预处理出$f[i][j]$表示序列上起点为$i$, 长度为$2^j$的区间的答案, 
查询的时候使用拼凑的方式把我们的答案拼凑出来就可以了. 比如快速查询区间最值, 区间按位或, 区间按位和, 区间最大
公约数等等. 他们都满足一个性质: $f[a..c] = f[a..b] \text{OP} f[b..c]$. 我们有$\mathcal O(n\log n)$
的时间预处理, $\mathcal O(1)$时间查询. 

\ti{P3865 ST表} 我们可以用上述的方法来完成这道问题. \file{st}

有些时候我们还会在树上的最近公共祖先中遇到这样的倍增的思想. 具体我们可以到时候再了解. 

\lec{矩阵介绍}{从方程组到矩阵} 接下来我们来引入一个比较有趣的想法. 也就是线性方程组和矩阵. 
在中小学的学习中, 我们可能遇到过形如这样的方程: 
$$\begin{cases}
a_{11}x_{1}+a_{12}x_{2} & =b_{1}\\
a_{21}x_{1}+a_{22}x_{2} & =b_{2}
\end{cases}$$
如果大家把它当做$x_1, x_2$的变量的话, 就可以解出$x_1, x_2$的值. 我们这一次重点来看
我们的消元法. 我们发现, 其实上文中的$x_1, x_2$之类的写了好多次. 在这种情况下, 
我们可以丢掉那些冗余的内容, 仅仅留下我们要的系数以及等式右边的值. 如下: 
$$
\begin{pmatrix}
    a_{11} & a_{12} &\mid b_1\\
    a_{21} & a_{22} &\mid b_2
\end{pmatrix}
$$
好了, 有了这个简化的记号, 我们可以认真思考一下矩阵的消元意味着什么了. 我们发现, 在消元的时候
我们无非在做三件事: 
\begin{itemize}[noitemsep]
    \item 互换两个方程的位置
    \item 某一个方程乘上$k$倍($k\neq 0$)
    \item 一个方程乘上$k$倍加到另一个上面去
\end{itemize}
这样一来, 我们的消元过程中做的事就非常明了了. 下一个问题是: 有没有什么办法让电脑帮我们消元?
这就需要探讨Gauss消元法了. 例如, 我们如果能把我们的方程组化为右边的这个形式: 
$$
\begin{array}{c}
    a_{11} x_{1}+a_{12} x_{2}+\cdots+a_{1 n} x_{n}=b_{1} \\
    a_{21} x_{1}+a_{22} x_{2}+\cdots+a_{2 n} x_{n}=b_{2} \\
    \vdots \\
    a_{n 1} x_{1}+a_{n 2} x_{2}+\cdots+a_{n n} x_{n}=b_{n}
    \end{array} \quad \Rightarrow \quad \begin{array}{r}
    a_{11}^{\prime} x_{1}+a_{12}^{\prime} x_{2}+\cdots+a_{1 n}^{\prime} x_{n}=b_{1}^{\prime} \\
    a_{22}^{\prime} x_{2}+\cdots+a_{2 n}^{\prime} x_{n}=b_{2}^{\prime} \\
    \vdots \\
    a_{n n}^{\prime} x_{n}=b_{n}^{\prime}
    \end{array}
$$
这下子来看我们就可以得到了$x_{nn}={b'_n}/{a'_{nn}}$. 接着, 有了$x_n$, 那么就解出了
$x_{n-1}$, 一直网上面反向带入, 就可以得到$x_1,\cdots, x_n$的值了. 

但是这样的想法到底能不能实现呢? 我们来实际的考察几例: 

第一个例子来自中国古代书本中记载的关于方程的问题. 来自《九章算術》一书. 原文说: 
\begin{quote}
    今有上禾三秉\footnote{〔秉〕:禾束,成把的禾.}, 中禾二秉, 下禾一秉, 實\footnote{〔实〕:古代算数书称被乘数, 被除数为``实数'', 简称``实''.}三十九斗；上禾二秉, 中禾三秉, 下禾一秉, 實三十四斗；上禾一秉, 中禾二秉, 下禾三秉, 實二十六斗. 問上、中、下禾實一秉各幾何？ 
\end{quote}
古文很难读懂, 我们翻译为现代的方程形式, 就是$\begin{cases}
    3x+2y+z=39\\
    2x+3y+y=34\\
    x+2y+3z=26
    \end{cases}$
翻译为矩阵, 就是
$\left(\begin{array}{cccc}3&2&1&39\\2&3&1&34\\1&2&3&26\end{array}\right)$. 我们先干掉第一列, 可以使用第 2 行乘以 3 减去第 1 
行乘以 2 , 第 3 行乘以 3 减去第 1 行, 可得
$$
\left(\begin{array}{cccc}3&2&1&39\\0&5&1&24\\0&4&8&39\end{array}\right).
$$
再用第 3 行乘以 5 减去第 2 行乘以 4 得到
$$
\left(\begin{array}{cccc}3&2&1&39\\0&5&1&24\\0&0&36&99\end{array}\right).
$$
然后我们把它想做一个方程, 现在已经知道了$36z=99$, 那么带入到上一个方程中, 再带回去, 就有: 
$$
\left(\begin{array}{cccc}1&0&0&37/4\\0&1&0&17/4\\0&0&1&11/4\end{array}\right).
$$

看似我们的确可以把它化为阶梯的样子. 下面我们来看另一个例子, 这个例子在经过几步变化之后
发生了不一样的事情: 
$$
\left(\begin{array}{cccc}1&1&1&1\\1&2&3&4\\0&1&2&4\end{array}\right)\to\left(\begin{array}{cccc}1&1&1&1\\0&1&2&3\\0&1&2&4\end{array}\right)\to\left(\begin{array}{cccc}1&1&1&1\\0&1&2&3\\0&0&0&1\end{array}\right)\to\left(\begin{array}{cccc}1&0&-1&0\\0&1&2&0\\0&0&0&1\end{array}\right). 
$$
哎呀! 我们出现了形如$0x=1$这样的式子. 这就表明, 这个方程式无解的. 因为没有这样的数, 使得 
$0x=1$. 这时候, 我们的方程就出现了无解的情况. 

当然, 我们也能发现有无数组解的情况. 也就是说, 在变化完为对角形之后, 如果最后的有``全0''的 
行, 但是右边的最后一个不等于0的话, 这个方程组无解; 最后一个如果也等于0的话, 这个方程组有
无数个解. 

所以, 我们如果不能把它化为阶梯型, 就说明它是无解的. 如果出现了类似$0x=i,i\neq 0$这样的式 
就说明了无解. 有$0x=0$的, 就表明了有无数组解答. 

\ti{P2455} 本题目涉及到浮点数的运算可能较为麻烦, 因为大家要尽量避免除法的精度带来的误差
造成对大家程序的影响. \file{P2455}

\lec{方程组变量代换}{矩阵乘法} 大家可能已经听说过矩阵乘法的关系式, 可是为什么这么奇怪?
矩阵乘法是 Cayley 在 1857 年左右发明的一个具有开创性的操作. 他提出的这个操作建立了
一个全新的代数体系. 

实际上, 方程组的视角来看, 矩阵乘法没有那么复杂. 矩阵乘法就相当于方程组的变量代换. 例如
$$
\left\{\begin{array}{l}a_{11}x_1+a_{12}x_2=c_1,\\a_{21}x_1+a_{22}x_2=c_2,\end{array}\right.\quad\left\{\begin{array}{l}b_{11}y_1+b_{12}y_2=x_1,\\b_{21}y_1+b_{22}y_2=x_2.\end{array}\right.
$$
将第二个方程组代入第一个中可以得到一个新的方程组: 
$$
\left\{\begin{array}{l}(a_{11}b_{11}+a_{12}b_{21})y_1+(a_{11}b_{12}+a_{12}b_{22})y_2=c_1,\\(a_{21}b_{11}+a_{22}b_{21})y_1+(a_{21}b_{12}+a_{22}b_{22})y_2=c_2,\end{array}\right.
$$
它的系数矩阵可以用这样直观的图示进行: 
$$
\begin{pmatrix} &  &  & b_{11} & b_{12}\\
    &  &  & b_{21} & b_{22}\\
    &  &  & \downarrow & \downarrow\\
   a_{11} & a_{12} & \rightarrow & a_{11}b_{11}+a_{12}b_{21} & a_{11}b_{12}+a_{12}b_{22}\\
   a_{21} & a_{22} & \rightarrow & a_{21}b_{11}+a_{22}b_{21} & a_{21}b_{12}+a_{22}b_{22}
   \end{pmatrix}
$$

这就解释了为什么会有这样的看似复杂的式子. 那么这样的一个``矩阵乘法''满足什么样的性质呢? 

矩阵乘法不满足交换律. 一个非常简单的例子可以看出来: 一个$3\times 4, 4\times 3$的矩阵
交换之后, 乘法无法进行. 另一方面, 即使他们的行和列的数量相同, 乘出来的矩阵也不一定一样. 

但是, 矩阵乘法满足结合律. 也就是对于矩阵$A,B,C$, 
$(A\times B)\times C=A\times (B\times C)$. 我们可以从变量替换的角度说明这个事情. 
更一般的方法就是看一看乘过之后的矩阵的第$i$行第$j$列的元素, 看看是不是一样的.
\begin{proof}
    我们只对结合律加以证明$A(BC)$的第 $i$ 行 $j$ 列元素为
    $$
    \begin{aligned}(A(BC))_{ij}=\sum_{k=1}^pa_{ik}(BC)_{kj}=\sum_{k=1}^p\sum_{l=1}^sa_{ik}b_{kl}c_{lj}=((AB)C)_{ij}.\end{aligned}
    $$
    因此 $A(BC) = (AB)C$.
\end{proof}

既然满足, 我们也可以对它使用快速幂. 比如快速地计算矩阵$A$的若干次方, 和刚刚说的是一样的. 

那它有什么用武之地呢? 毕竟, 好像没啥人希望计算一个奇形怪状矩阵的若干次方. 其实, 我们回到
我们的Fibonacci数列, 其实这里面这一个递推式就隐藏着矩阵乘法. 我们发现每一个值都是它前两项
的线性组合. 

设 Fib$(n)$表示一个$1\times 2$的矩阵$[F_n, F_{n-1}]$. 我们希望根据
 $\text{Fib}(n-1)=\left[\begin{array}{cc}F_{n-1}&F_{n-2}\end{array}\right]$
 推出 Fib$(n)$. 
试推导一个矩阵的奠基, 使 F$(n -1)\times $ base = F$(n)$, 即$[F_{n-1}\quad F_{n-2}]\times\mathrm{base}=[F_{n}\quad F_{n-1}]$. 

怎么推呢？根据递推关系, $F_n=F_{n-1}+F_{n-2}$ , 
所以 base矩阵第一列应该是$\left[\begin{array}{c}1\\1\end{array}\right],$
这样在进行矩阵乘法运算的时候才能令 $F_{n-1}$ 与 $F_{n-2}$ 相加, 从而得出$F_n$. 同理, 为了得出 $F_{n-1}$ , 矩阵 base的第二列应该为$\left[\begin{array}{c}1\\0\end{array}\right]$. 

综上所述: base $=\left[\begin{array}{cc}1&1\\1&0\end{array}\right],$ 原式化为$[F{n-1}
\quad F_{n-2}]\times\left[\begin{array}{cc}1&1\\1&0\end{array}\right]
=\left[\begin{array}{cc}F_n&F_{n-1}\end{array}\right]$ 因此, 我们就得到了递推矩阵
base=$\left[\begin{array}{cc}1&1\\1&0\end{array}\right]$. 

\ti{P1962 斐波那契数列} 我们按照刚刚的方法解答就好了. 对于一些线性的递推
式子, 我们有时候可以使用这样的方法做这个问题. 

对于评论区题解的特征方程的方法, 如有兴趣, 大家可以参考一些大学教科书. 来了解其背后的
原理. \mn{如果大家想要了解更多, 欢迎参看朱富海老师编写的《高等代数与解析几何》\cite{zhu2018}, 
以及李尚志老师编写的《线性代数学习指导》\cite{li2015}. }

\subsection*{闲聊与练习}

\begin{exercise}{ST表与RMQ(Range Mininum Query)}
    请完成\ti{P1440 求m区间内的最小值}, 加深对于最小值的理解. 顺便这个问题使用
    ST表相关的问题求解的时候注意空间. 有一些无用的空间可以复用. 
\end{exercise}

\begin{exercise}{最近公共祖先}
    你已经了解了树. 那么两个树的最近公共祖先应该如何求? 一个想法是先让他们跳到一样的
    高度, 然后一层一层往上跳. 但是不巧的是, 一层一层往上跳太慢了. 因此可以一次向上
    跳$2^k$个单位. 只要他们相遇了, 就缩小$k$的值, 直到最后他们的父亲节点是同一个节点,
    他们的父亲节点就是最近公共祖先. 

    这就是倍增的实际应用. 如果感觉比较迷糊, 可以看\href{https://www.bilibili.com/video/BV1N7411G7JD}{这里的一个可视化资源}. 注意! 这个视频可能有一些错误. 如果
    发现一些胡说八道的情况, 基本上你是对的. 然后你可以完成\ti{P3379 【模板】最近公共祖先(LCA)}. 
\end{exercise}

\begin{exercise}{认识矩阵}
    现在再阅读矩阵的定义, 是不是更好懂了一点? 实际上, 除了解方程组的角度, 我们
    还可以使用图像化和可视化的方法理解矩阵和背后的一点点线性代数. 

    请欣赏3Blue1Brown制作的\href{https://www.bilibili.com/video/BV1ys411472E}{《线性代数的本质》}系列视频. 并简单感受其中的一些思想. 

    如果发现看英文视频不习惯, \href{https://www.bilibili.com/video/BV1ib411t7YR}{这里}有一份中文配音的版本. 但是我们还是推荐使用英语看完本系列, 因为逻辑流很通顺.
    
\end{exercise}

\begin{exercise}{矩阵加速线性递推}
    可以完成\ti{P1939 【模板】矩阵加速（数列）}以及\ti{P3390 【模板】矩阵快速幂}来加深
    对于矩阵快速幂的理解. 
    
\end{exercise}

\section{更多的练习与思考}

除此之外, 我们还会有很多很有趣的思考问题的方法. 我们下面举出几个例子: 

\lec{滑动窗口}{介绍} 我们在有些问题的时候, 要求一个固定长度的区间内部的最大值和最小值都输出
出来. 我们有
如果我们使用暴力的做法, 可以这样做: 可以先用一个队列来维护窗口, 保证每次这个窗口里面存的是当前的所有元素. 
遍历所有元素, 得到时间的复杂度是$\mathcal O(nk)$. 但是我们想一想这个真的需要这么复杂吗? 

考虑优化, 有些元素似乎是没用了的. 比如我们要看窗口长度为3的序列. 我们发现, 
我们要求最小值, 我们只要严格递减就可以了. 另外, 适时地弹出不在队伍里面的元素,
就能维持答案的准确性. 也就是说, 单调队列的主要特点是保持队列内元素的单调性, 这使
得在每次添加新元素时, 队列内的元素仍然保持单调性, 从而保证了队列操作的高效性.  

\incfig{opt-search/sin-sta}

我们来看单调队列的代码: 注意这里表示了那些元素的编号在队伍里面. 
\file{slide-window}, 并且可以尝试做习题\ti{P1886 滑动窗口}. 

\lec{并查集}{简介} 并查集主要用于解决元素的所属关系, 也就是看一看两个内容是不是在同一类中. 
具体地, 就有如下的两点要求: 
\begin{itemize}[noitemsep]
    \item 将两个集合合并
    \item 判定两个元素是不是在一个集合中
\end{itemize}

要达到这个目的, 我们可以采用这样的策略: 每个集合用一棵树来表示, 树根的编号就是整个集合的编号, 
每个节点储存着他的父节点的编号, \codeword{p[x]}表示\codeword{x}的父节点. 

那么我们的几个操作就可以这样表示了: 
\begin{itemize}[noitemsep]
    \item 判断树根: \codeword{p[x]==x}
    \item 求\codeword{x}集合所在的编号: \codeword{while(p[x]!=x) x = p[x]}
    \item 合并两个集合\codeword{px,py}, $x\neq y$. \codeword{p[x]=y}.
\end{itemize}

\begin{lstlisting}
    int a, b; 
    int p[MAXN];
    // 返回x属于的是哪一类中的
    int find(int x){
        // 路径压缩
        if(p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    
    int main(){
        scanf("%s%d%d", op, &n, &m);
        for(int i=1; i<=n; i++) {
            p[i] = i;
        }
        //... 读入a, b
        // 把a插入到b身上, 修改p[find(a)]
        if(op[0]=='M') p[find(a)] = find(b);
        else {
            if(find(a) == find(b)){
                puts("Yes");
            }else puts("No");
        }
        return 0;
    }
\end{lstlisting}

\ti{P3367 并查集} 这个问题是一个标准的并查集的问题. 可以用作练习. \file{P3367}. 

我们使用并查集还可以维护并查集中的点的数量. 比如, 我们要是问这个并查集里面一共有几个元素, 应该怎么办?
一个原则就是可以这样修改我们的并查集代码, 额外维护一个\cw{size}数组, 每次更新的时候把值加上去. 
也就是多出了一行\cw{size[find(b)] += size[find(a)];}. 具体我们可以看代码\file{point-no}.

我们来看一个并查集的另一个变形, 带权并查集. 我们刚刚在点上面打上了标记, 现在我们来看一看边上有什么
可以做的. 带权并查集是在并查集的边上定义某种权值, 以及这种权值在路径压缩时发生的运算, 来达到
解决更多问题的结果. 我们来看下面的问题: 

\ti{P2024 食物链} 我们这时候定义并查集边上的节点为维护到根节点的距离. 这样一来, 就可以使用
用并查集维护额外信息. 这个听起来看上去很难说, 但是我们来观察一些简单的性质: 
\incfig{opt-search/fodchain.png}
于是我们就可以写出代码\file{P2024}.

\subsection*{闲聊与练习}

\begin{exercise}{滑动窗口的编程习题}
    以下的问题是滑动窗口的一些练习题: 

    (1) 最大子序和

    仿照滑动窗口, 可以写出单调栈的原理. 如下是一些练习题. 如果感到困难, 推荐在DP之后
    回过来看: 

    (1) P5788 单调栈模板题

    (2) POJ-3250 Bad Hair Day 

    (3) P4147 玉蟾宫
\end{exercise}

\begin{exercise}{并查集的相关编程习题}
    下面的一些内容是并查集相关的练习. 

    (1) P1955 程序自动分析

    (2) P1196 银河英雄传说

    (3) P1892 团伙

    (4) P1525 关押罪犯

\end{exercise}
\part{树与图}

拿着郑州市的地图, 在所有两条或多条街道的汇合处或一条街道的尽头都画上一
个黑点, 这样就有了一个组合数学中的图的例子. 在这个城市中, 某些街道是单行道, 
只允许单向行驶, 因此你可以在每一条单行道的行进方向上画一个箭头$\rightarrow$, 
在所有的双行道上画一个双箭头$\leftrightarrow$. 
考虑栖息在你喜爱城市里的所有的动物和植物, 如果一个物种捕食另一个物种, 
就在它们之间画上一个箭头, 这样你又得到了一个有向图. 得到了我们学习的食物网. 

上述的例子说明, 图和有向图为相关对象可以让我们理解事情更加清晰. 图在计算机科学中也
是一种极为有用的模型, 因为在计算机科学中出现的许多问题, 都能够很容易地通过图的算法
去刻画. 在这之前, 我们要来看一看一些简单的内容: 

\section{图的关键要素和存储}

正如我们刚刚看到的, 我们发现图无非是一些节点和一些边组成的. 

\begin{definition}
一个图$G$ (也叫做简单图) 是由两类对象构成的. 它有一个被称为顶点 (有时也叫做结点
的元素的集合
$$
V=\{a,b,c,\cdots\}
$$
和一个被称为边的不同顶点对的有限集合$E$, 我们用
$$
G=(V,E)
$$
表示以$V$为顶点, $E$为边的图. 
\end{definition}

\begin{example}
一个有5个顶点的图G的顶点是
$$
V=\{a,b,c,d,e\}
$$
以及边是
$$
E=\left\{\left\langle a,b\right\rangle,\left\langle b,c\right\rangle,\left\langle c,d\right\rangle\left\langle d,a\right\rangle,\left\langle e,a\right\rangle,\left\langle e,b\right\rangle,\left\langle e,d\right\rangle\right\}.
$$
\end{example}

所以, 关键是把握住如何向计算机里面塞入这些数据. 我们有两种做法: 

\ca{枚举每一个点对之间有没有边} 这样子, 我们可以开一个二维数组$g[i][j]$. 
其中$g[a][b]$如果是0, 那么说明这两个点之间没有边, 反之认为两个点之间有边. 
上面的可以用如下的二维数组表示: TBD 

\ca{在每一个节点上维护一个它可以到的相邻节点的列表} 这个列表的实现方式可能有很多种, 
比如``链式前向星''就使用一个类似于链表的结构记录了这个列表. 有些时候, 可以使用
另一个数组\codeword{vector}来进行存储. 

TBD 加一个图

那么如果想到达相邻节点的相邻节点怎么办? 我们又没有存储它.
没关系, 我们只要先到一个相邻节点, 再在另一个相邻节点的位置上找到那个相邻的节点就
可以了. 也就是说, 我们只要能够维护一个相邻节点的关系, 我们就可以在整个图上到达我们
可以到达的节点了. 

\ti{*通过手动模拟理解链式前向星的加边代码} 有些时候我们会使用一个链表来进行加班的操作. 
我们来看代码: 

\begin{lstlisting}
    int cnt=0; // 记录当前是第几条边
    int head[MAXN]; //head[u]表示最后一条从u出发的边
    struct Edge{
        int to,next,val;
        //to:从u出发到的节点
	    //next: 前一条从u出发的边的cnt的值
	    //val: 当前边边权
    }e[MAXN];
\end{lstlisting}

我们来看一个问题的练习: 

\ti{B3643 图的存储} 这个是基本的问题. 让我们用不同的方法来进行书写. 
\file{graph-store-1}
由于这个问题需要我们排序输出, 所以我们还是不要使用链表的方式了. 因为排序的
时候会很麻烦. 

树的节点除了可以存当前的节点编号, 还可以维护一些辅助的信息; 边除了边的权重, 
还可以加一些辅助的信息在边上. 这就需要具体看问题具体分析了. 

下面我们来看一个可以用刚刚说的链式前向星进行的例子: 当然这个可能复杂了一些. 

\ti{P3916 图的遍历} 一个朴素的算法是从每个点搜索能到达的点, 再找出最大的.
但是这样的内容显然是无法处理$\mathcal O(n^2)$的数据的. 我们需要一些优化. 
由于是最大的, 我们可以提前指定一个序关系, 使得我们从答案出发, 看一看哪些点
会最终到达这个答案. 这就要求我们建立一个反向边就行了. 

所以, 我们的策略是: 应该按编号从大到小DFS每个节点, 这样能保证一个点在被
第一次访问的时候一定是能够到达最大的值的. 这样, 每个点就要访问1次, 从的时间
复杂度是$\mathcal O(n)$, 可以做到. \file{P3916}

如果你有时候觉得中括号太多了, 可以把\codeword{to, next}从结构体里面提出来
写成数组, 这样一来\codeword{e[i].to}就可以直接写作\codeword{to[i]}. 
当然是只有一个图的时候这样子也是可以的. 

我们发现运用图来解决问题很多时候是很有趣的, 我们会简单说明有些常用的算法, 并
做一点简单的应用. 

\section{常见图算法}

\lec{拓扑排序}{介绍} 想象一下, 你身为一个小组的学生们计划一个综合项目. 
每个学生都有自己的任务, 但某些任务必须在其他任务之前完成. 
我们要使用拓扑排序来确定任务的顺序. 

假设我们的任务有: A - 搜集信息, B - 分析数据, C - 编写报告, D - 进行演示. 
现在让我们来看看每个任务之间的依赖关系. 

A不依赖其他任务, 所以它排在第一位. 
B依赖于A, 所以它排在A之后. 
C依赖于B, 所以它排在B之后. 
D依赖于C, 所以它排在C之后. 

所以最终的任务顺序是: $A \rightarrow  B \rightarrow  C \rightarrow  D$. 

要进行拓扑排序, 我们(1)首先找到所有没有前置依赖的顶点 (入度为0的顶点) . 
这些顶点可以作为排序序列的起点. (2)然后, 从上一步得到的顶点中选择一个作为当
前的顶点, 并将其添加到排序序列中. (3)将当前顶点从图中移除, 
并更新与其相关的顶点的入度. 具体地说, 对于每个与当前顶点相邻的顶点, 将其入度减1. 
(4)重复步骤2和3, 直到所有的顶点都被处理和移除. 
如果在这个过程中存在入度为0的顶点, 就继续选择一个添加到排序序列中. 
最终, 得到的排序序列就是一个满足依赖关系的顶点顺序, 表明了任务的执行顺序的序列.

在2020年的
NOIP中, 我们确实需要写这样一个内容, 不过需要加上高精度. 不加上高精度可以得到部分
的分数. 

\ti{P7113 排水系统} 这是一个拓扑排序的问题, 这里大家只要简单模拟就行了. 
当然注意分数通分的时候应该先加再乘. 当年也是因为这个丢掉了很多的分数. 

\ti{P1038 神经网络} 我们必须保证前面的点都已经算过了, 我们才可以计算这个点. 
所以, 我们就必须按照拓扑顺序来执行这些内容.

\ti{P3243 菜肴制作} 这是一个拓扑排序的例子. 但是会发现一个问题, 这里的要求是
尽量先吃到质量高的菜肴. 那么应该怎么办? 可以让小的菜编号为$a$, 
大的胃$b$. 我们尽量想让$a$往前靠, 但是这个难以计算. 我们可以尝试
让$b$尽量往后靠. 这样不论$b$在哪, 都能保证
$a$在前面, 可以反向拓扑排序. (这时候还需要使用优先队列\mn{优先
队列是可以让最大值出队列的一种数据结构. }进行维护) 

\lec{最短路}{介绍} 我们可以运用怎样的方法求得一个图中的最短路呢? 


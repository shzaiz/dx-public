\part{树与图}

拿着郑州市的地图, 在所有两条或多条街道的汇合处或一条街道的尽头都画上一
个黑点, 这样就有了一个组合数学中的图的例子. 在这个城市中, 某些街道是单行道, 
只允许单向行驶, 因此你可以在每一条单行道的行进方向上画一个箭头$\rightarrow$, 
在所有的双行道上画一个双箭头$\leftrightarrow$. 
考虑栖息在你喜爱城市里的所有的动物和植物, 如果一个物种捕食另一个物种, 
就在它们之间画上一个箭头, 这样你又得到了一个有向图. 得到了我们学习的食物网. 

上述的例子说明, 图和有向图为相关对象可以让我们理解事情更加清晰. 图在计算机科学中也
是一种极为有用的模型, 因为在计算机科学中出现的许多问题, 都能够很容易地通过图的算法
去刻画. 在这之前, 我们要来看一看一些简单的内容: 

\section{图的关键要素和存储}

正如我们刚刚看到的, 我们发现图无非是一些节点和一些边组成的. 

\begin{definition}
一个图$G$ (也叫做简单图) 是由两类对象构成的. 它有一个被称为顶点 (有时也叫做结点
的元素的集合
$$
V=\{a,b,c,\cdots\}
$$
和一个被称为边的不同顶点对的有限集合$E$, 我们用
$$
G=(V,E)
$$
表示以$V$为顶点, $E$为边的图. 
\end{definition}

\begin{example}
一个有5个顶点的图G的顶点是
$$
V=\{a,b,c,d,e\}
$$
以及边是
$$
E=\left\{\left\langle a,b\right\rangle,\left\langle b,c\right\rangle,\left\langle c,d\right\rangle\left\langle d,a\right\rangle,\left\langle e,a\right\rangle,\left\langle e,b\right\rangle,\left\langle e,d\right\rangle\right\}.
$$
\end{example}

所以, 关键是把握住如何向计算机里面塞入这些数据. 我们有两种做法: 

\ca{枚举每一个点对之间有没有边} 这样子, 我们可以开一个二维数组$g[i][j]$. 
其中$g[a][b]$如果是0, 那么说明这两个点之间没有边, 反之认为两个点之间有边. 
上面的可以用如下的二维数组表示: 
\incfig{graph/graph-intro.png} 

\ca{在每一个节点上维护一个它可以到的相邻节点的列表} 这个列表的实现方式可能有很多种, 
比如``链式前向星''就使用一个类似于链表的结构记录了这个列表. 有些时候, 可以使用
另一个数组\codeword{vector}来进行存储. 
\incfig{graph/reach.png}

那么如果想到达相邻节点的相邻节点怎么办? 我们又没有存储它.
没关系, 我们只要先到一个相邻节点, 再在另一个相邻节点的位置上找到那个相邻的节点就
可以了. 也就是说, 我们只要能够维护一个相邻节点的关系, 我们就可以在整个图上到达我们
可以到达的节点了. 

\ti{*通过手动模拟理解链式前向星的加边代码} 有些时候我们会使用一个链表来进行加边的操作. 
我们来看代码: 

\begin{lstlisting}
    int cnt=0; // 记录当前是第几条边
    int head[MAXN]; //head[u]表示最后一条从u出发的边
    struct Edge{
        int to,next,val;
        //to:从u出发到的节点
	    //next: 前一条从u出发的边的cnt的值
	    //val: 当前边边权
    }e[MAXN];

    void adde(int x, int y, int val){
        e[++cnt].nxt=head[x];
        head[x]=cnt;
        e[cnt].to=y;
        e[cnt].val = val;
    }   
\end{lstlisting}

我们来看一个问题的练习: 

\ti{B3643 图的存储} 这个是基本的问题. 让我们用不同的方法来进行书写. 
\file{graph-store-1}
由于这个问题需要我们排序输出, 所以我们还是不要使用链表的方式了. 因为排序的
时候会很麻烦. 

树的节点除了可以存当前的节点编号, 还可以维护一些辅助的信息; 边除了边的权重, 
还可以加一些辅助的信息在边上. 这就需要具体看问题具体分析了. 

能够存了图, 我们给出他们常见的一些操作. 

\lec{遍历图}{直接存边} 这个就需要我们对于边去枚举了. 这个的时间复杂度还是相当高的. 因为要访问扫描很多不必要的边. 并且遍历的时候会比较糟糕.
\begin{lstlisting}
    struct Edge {
        int u, v;
    };
//...
    bool find_edge(int u, int v) {
        for (int i = 1; i <= m; ++i) {
            if (e[i].u == u && e[i].v == v) {
            return true;
            }
        }
        return false;
    }
    void dfs(int u) {
        if (vis[u]) return; // 访问过了就返回
        vis[u] = true;
        for (int i = 1; i <= m; ++i) {
            if (e[i].u == u) {
            dfs(e[i].v);
            }
        }
    }
\end{lstlisting}

因此加入有$n$个点, $m$条边的话, 那么我们有如下的表格: 

\lec{遍历图}{使用关系矩阵} 


\ti{P3916 图的遍历} 一个朴素的算法是从每个点搜索能到达的点, 再找出最大的.
但是这样的内容显然是无法处理$\mathcal O(n^2)$的数据的. 我们需要一些优化. 
由于是最大的, 我们可以提前指定一个序关系, 使得我们从答案出发, 看一看哪些点
会最终到达这个答案. 这就要求我们建立一个反向边就行了. 

所以, 我们的策略是: 应该按编号从大到小DFS每个节点, 这样能保证一个点在被
第一次访问的时候一定是能够到达最大的值的. 这样, 每个点就要访问1次, 从的时间
复杂度是$\mathcal O(n)$, 可以做到. \file{P3916}

如果你有时候觉得中括号太多了, 可以把\codeword{to, next}从结构体里面提出来
写成数组, 这样一来\codeword{e[i].to}就可以直接写作\codeword{to[i]}. 
当然是只有一个图的时候这样子也是可以的. 



我们发现运用图来解决问题很多时候是很有趣的, 我们会简单说明有些常用的算法, 并
做一点简单的应用. 



\section{常见图算法}

\lec{拓扑排序}{介绍} 想象一下, 你身为一个小组的学生们计划一个综合项目. 
每个学生都有自己的任务, 但某些任务必须在其他任务之前完成. 
我们要使用拓扑排序来确定任务的顺序. 

假设我们的任务有: A - 搜集信息, B - 分析数据, C - 编写报告, D - 进行演示. 
现在让我们来看看每个任务之间的依赖关系. 

A不依赖其他任务, 所以它排在第一位. 
B依赖于A, 所以它排在A之后. 
C依赖于B, 所以它排在B之后. 
D依赖于C, 所以它排在C之后. 

所以最终的任务顺序是: $A \rightarrow  B \rightarrow  C \rightarrow  D$. 

要进行拓扑排序, 我们(1)首先找到所有没有前置依赖的顶点 (入度为0的顶点) . 
这些顶点可以作为排序序列的起点. (2)然后, 从上一步得到的顶点中选择一个作为当
前的顶点, 并将其添加到排序序列中. (3)将当前顶点从图中移除, 
并更新与其相关的顶点的入度. 具体地说, 对于每个与当前顶点相邻的顶点, 将其入度减1. 
(4)重复步骤2和3, 直到所有的顶点都被处理和移除. 
如果在这个过程中存在入度为0的顶点, 就继续选择一个添加到排序序列中. 
最终, 得到的排序序列就是一个满足依赖关系的顶点顺序, 表明了任务的执行顺序的序列.

在2020年的
NOIP中, 我们确实需要写这样一个内容, 不过需要加上高精度. 不加上高精度可以得到部分
的分数. 

\ti{P7113 排水系统} 这是一个拓扑排序的问题, 这里大家只要简单模拟就行了. 
当然注意分数通分的时候应该先加再乘. 当年也是因为这个丢掉了很多的分数. 

\ti{P1038 神经网络} 我们必须保证前面的点都已经算过了, 我们才可以计算这个点. 
所以, 我们就必须按照拓扑顺序来执行这些内容.

\ti{P3243 菜肴制作} 这是一个拓扑排序的例子. 但是会发现一个问题, 这里的要求是
尽量先吃到质量高的菜肴. 那么应该怎么办? 可以让小的菜编号为$a$, 
大的胃$b$. 我们尽量想让$a$往前靠, 但是这个难以计算. 我们可以尝试
让$b$尽量往后靠. 这样不论$b$在哪, 都能保证
$a$在前面, 可以反向拓扑排序. (这时候还需要使用优先队列\mn{优先
队列是可以让最大值出队列的一种数据结构. }进行维护) 


\lec{最短路算法}{介绍} 最短路算法是图论中的一个经典问题, 它用于寻找图中两个顶点之间最短路径的问题. 
最短路算法的核心过程是通过遍历图中的边和顶点, 找到连接起点和终点的最短路径. 

\lec{最短路算法}{Floyd算法} 给定一个带有边权的有向图, 我们的目标是找出图中任意两个
顶点之间的最短路径长度. 这个问题被称为全源最短路问题, 因为我们需要找出从图中每一个顶点
到其他所有顶点的最短路径. 

首先一个基本的问题是, 从$u$到$v$, 如果我们找到了一个节点$k$, 使得
$\text{dis}(u,v)\geq \text{dis}(u,k)+\text{dis}(k,v)$,
那么我们就可以通过$u\to k\to v$的方法经过路经. 

算法的流程如下: 首先, 我们需要构建一个二维数组\codeword{dist}, 用来存储每对顶点之间的最短路径长度. 
如果两个顶点之间没有直接的边相连, 则将其距离设置为无穷大. 接下来, 我们初始化\codeword{dist}数组. 
对于每一条边$(i, j)$, 我们将\codeword{dist[i][j]}设置为边的权重值. 如果没有边直接相连, 
则将\codeword{dist[i][j]}设置为无穷大. 

然后, 我们使用三层循环遍历所有顶点, 并尝试通过第三个顶点$k$来优化从顶点$i$到顶点$j$的最短路径. 
具体来说, 我们检查是否存在从$i$到$j$经过顶点$k$的路径长度比直接从$i$到$j$的路径更短. 
如果是, 则更新\codeword{dist[i][j]}为更短的路径长度. 

这个算法的证明, 如有兴趣请参考\cite{algobook}, 其中介绍了这个算法的历史. 我们可能需要
在理解动态规划的思想之后再回来看它会比较好. 

实际上, 这个Floyd算法可以用作另一种情形. 用于求``传递闭包(transitive closure)''. 
那么, 什么是传递闭包呢? 通俗的讲就是如果$a\to b$,  $b\to c$, 那么我们就建立一条
$a\to c$的边. 将所有能间接相连的点直接相连. 为什么这样做? 因为这个做就构造出了重要的
``可达关系''. 我们就不用再枚举了. 

\begin{lstlisting}
void Floyd() {
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (g[i][k] && g[k][j]) g[i][j] = 1;  
            }
        }
    }
}
\end{lstlisting}

\ti{B3611 【模板】传递闭包} 我们可以用练习B3611来练习我们的这个算法. 

\ti{\href{http://poj.org/problem?id=1975}{POJ1975 Median Weight Bead}} 
题目大意: 给出一些水滴之间的的重量大小关系, 求有多少滴水滴的重量不可能是这些水滴重量的中位数.  (水滴的数量保证为奇数) 

这就可以建个图来转化问题. 假设$w_i$表示水滴的重量, $i$到$j$有边代表$w_i>w_j$. 
求传递闭包, 对每个点都统计能到达多少个点、有多少个点能到达. 
如果这两个数中有一个大于$n/2$, 那它就不可能成为中位数. 



\lec{最短路算法}{Bellman-Ford算法} 有$n$个点, $m$条边, 除了起点, 最短路中最多还有$n-1$个点, 
所以最多对$m$条边进行$n-1$轮松弛操作. 所谓``松弛'', 就是像Floyd算法那样, 如果找到了更小的, 就
不断地更新dis的值为更小的那一个. 
\begin{lstlisting}
for(int i=1;i<n;i++){
    for(int j=1;j<=m;j++)
    dis[v]=min(dis[v],dis[u]+val[u][v]);
}    
\end{lstlisting}

当然, 这个算法是有一些慢的. 我们考虑加上一些优化: 

\ca{优化1. 减少不必要的循环} 我们可以添加flag, 第i轮如果flag的值没有改变, 直接跳出循环, 
我们就可以结束了, 减少循环的次数. 
\begin{lstlisting}
int flag=1;
for(int i=1;i<n;i++){
    flag=1;
    for(int j=1;j<=m;j++){
        if(dis[v]>dis[u]+val[u][v]){
            dis[v]=dis[u]+val[u][v];
            flag=0;
        }
    }
    if(flag)break;
}    
\end{lstlisting}

\ca{优化2. 用queue存目前已经更新过的最短的路的节点} 我们发现似乎没必要
使用那么多的松弛操作. 只有上一次被松弛的结点, 所连接的边, 才有可能引起下一次的松弛操作. 
这就启发我们用队列来维护哪些结点可能会引起松弛操作, 就能只访问必要的边了. 

\ti{P3371 单源最短路(弱化版)} 请参看代码\file{P3371}. 

这份优化同样可以判断负环. 同一条边入队次数大于等于$m$ (或者点更新的次数大于某个数, 一般是$n$) , 
说明存在一条路, 满足只要一直走这一条路, 这条路上节点的\codeword{dis[]}会不断减小. 也
就是, 这条路是负环！

这种优化方法优化出来正是SPFA, SPFA可以用来判断负环是否存在. 

\ti{P3385 判断负环} 请参考\file{P3385}.

大家可能听闻了``卡spfa''的声音. 实际上, 比如在网格图、菊花图之类的图上面它的复杂度是不稳定的. 
所以说在没有负权环的情况下慎用spfa. 

\lec{最短路算法}{Dijkstra算法} 如果我们按照spfa的想法, 在没有负边权的情况下, 用优先队列优化, 
和BFS一样, 我们就得到了Dijkstra算法. 

算法的过程是, 将结点分成两个集合: 已确定最短路长度的点集 (记为 $S$ 集合) 
的和未确定最短路长度的点集 (记为 $T$ 集合) . 一开始所有的点都属于 $T$ 集合. 
初始化的时候 $dis(s)=0$, 其他点的 $dis$ 均为 $+\infty$. 

然后重复这些操作: (1) 从 $T$ 集合中, 选取一个最短路长度最小的结点, 移到 $S$ 集合中. 
对那些刚刚被加入 $S$ 集合的结点的所有出边执行松弛操作. 
(2) 直到 $T$ 集合为空, 算法结束. 

这里最小长度就展示我们用堆优化的方法来做这个问题了. 直观来看, 这个算法从已知点不断向未知点搜索, 
每个点只入队出队1次, 所以从每个点出发的边只遍历1次, 再加上优先队列入队的复杂度为$O(m\log n)$. 

这方面的代码可以这样写: 

\begin{lstlisting}
    struct nodei{
        int dis,pos;
        bool operator <(const nodei &x)const{
            return x.dis <dis;
        }
    };
    void dijkstra(int s){ //s是起点
        std::priority_queue<nodei>q;
        dis[s]=0;
        q.push((nodei){0,s});
        while(!q.empty()){
            nodei tmp=q.top();
            q.pop();
            int x=tmp.pos ,d=tmp.dis ;
            if(vis[x])continue;
            vis[x]=1;
            for(int i=head[x];i;i=a[i].next ){
                int v=a[i].to ;
                if(dis[v]>dis[x]+a[i].val ){
                    dis[v]=dis[x]+a[i].val ;
                    if(!vis[v])//vis的值的含义: 0=这个点没有入队过 1=入队过
                    q.push((nodei){dis[v],v});
                }
            }
        }
    }    
\end{lstlisting}


我们可以使用数学归纳法来证明这个算法
的确是正确的. 

\begin{proof}
    我们要证, 在执行 1 操作时, 取出的结点 $u$ 最短路均已经被确定, 即满足 $D(u) = dis(u)$. 

初始时 $S = \varnothing$, 假设成立. 

接下来用反证法. 

设 $u$ 点为算法中第一个在加入 $S$ 集合时不满足 $D(u) = dis(u)$ 的点. 
因为 s 点一定满足 $D(u)=dis(u)=0$, 
且它一定是第一个加入 $S$ 集合的点, 因此将 $u$ 加入 $S$ 集合前, $S \neq \varnothing$, 
如果不存在 $s$ 到 $u$ 的路径, 则 $D(u) = dis(u) = +\infty$, 与假设矛盾. 

于是一定存在路径 $s \to x \to y \to u$, 其中 $y$ 为 $s \to u$ 路径上第一个属于 $T$
集合的点, 而 $x$ 为 $y$ 的前驱结点 (显然 $x \in S$) . 需要注意的是, 可能存在 $s = x$ 或 
$y = u$ 的情况, 即 $s \to x$ 或 $y \to u$ 可能是空路径. 

因为在 $u$ 结点之前加入的结点都满足 $D(u) = dis(u)$, 所以在 $x$ 点加入到 $S$ 集合时, 
有 $D(x) = dis(x)$, 此时边 $(x,y)$ 会被松弛, 从而可以证明, 
将 $u$ 加入到 $S$ 时, 一定有 $D(y)=dis(y)$. 

下面证明 $D(u) = dis(u)$ 成立. 在路径 $s \to x \to y \to u$ 中, 
因为图上所有边边权非负, 因此 $D(y) \leq D(u)$. 从而 $dis(y) \leq D(y) \leq D(u)\leq dis(u)$. 
但是因为 $u$ 结点在 $1$ 过程中被取出 $T$ 集合时, $y$ 结点还没有被取出 $T$ 集合, 因
此此时有 $dis(u)\leq dis(y)$, 从而得到 $dis(y) = D(y) = D(u) = dis(u)$, 这与 
$D(u)\neq dis(u)$ 的假设矛盾, 故假设不成立. 

因此我们证明了, 1 操作每次取出的点, 其最短路均已经被确定. 命题得证. 
\end{proof}

\ti{P1462 通往奥格瑞玛的道路} 我们发现, 求能到达终点路径上的收取的最大的费用的最小值, 
我们可以用二分答案, 二分最大的费用. 如果最开始限制为inf依旧不能到达终点, 输出AFK. 
如果可以到达终点, 进行二分.\file{P1462}

有时候我们可以将原来的图``分层'', 并且在分层图上跑最短路. 这也就可以让我们对不同的节点
之间表示的``状态''产生了区别. 这样, 最短路算法就可以帮助我们在这个模型上面跑出一个最短的
路径. 因此是一个聪明的做法. 

\ti{P1073 最优贸易} 我们可以当我们进行买入操作, 我们就建立一条有向边转移到一张新图上, 
大小为$-v_i$, 指向第二层到达的$i_1$. 
这样一来, 假如我选择走了这条边, 就意味着我在这个点买了这个水晶球, 我不会回到第一层, 我接下
来考虑在某个点卖它. 当我们进行卖出操作, 我们建立一条有向边转移到第三层图上, 边的大小为$+v_i$,
它从第二层的点指向第三层的点. 这表示假如我选择走了这条边, 就是我在这个点卖了这个水晶球, 
我不会返回到上面的层数, 并且我接下来考虑走向终点. 这样一来, 在这个分了层的图上, 最短路
算法自然会帮助我们来选择合适的路线. 


\lec{最小生成树}{简介} 假设有一个表示城市之间道路的图, 每条边表示两个城市之间的道
路, 边的权重表示旅行的距离或成本. 我们要找出连接所有城市并且总旅行距离最短的道路网
络, 即最小生成树. 

我们介绍基于贪心策略的Kruskal算法. 其第一步为给所有边按照从小到大排序. 然后 
依次考察每条边$(u,v)$. 考虑如下两种情况: 
\begin{itemize}[noitemsep]
    \item $u$和$v$在同一个联通分量里面. 那么加入这个会构成一个环. 我们不选择. 
    \item 如果$u$和$v$在不同的联通分量里面, 那么加入$(u,v)$一定是最优的. 因为假设它不是最优的, 而有一个更小的生成树, 也就是说有一个更小的$(u',v')$, 这与我们已经有序的边的长度的列表产生了矛盾. 
\end{itemize}

我们应该如何维护一个两个点是不是在联通分量里面呢? 直接用并查集维护就可以了. 

另外一种做法是使用Prim算法. 这个算法的做法很像Dijkstra的最短路径算法. 
它的算法过程是: 
\begin{itemize}[noitemsep]
    \item 以某一个点开始, 寻找当前该点可以访问的所有的边；
    \item 在已经寻找的边中发现最小边, 这个边必须有一个点还没有访问过, 将还没有访问的点加入我们的集合, 记录添加的边；
    \item 寻找当前集合可以访问的所有边, 重复2的过程, 直到没有新的点可以加入；
    \item 此时由所有边构成的树即为最小生成树. 
\end{itemize}

Prim算法之所以是正确的, 主要基于一个判断: 对于任意一个顶点$v$, 连接到该顶点的所有边中的一条最短边$(v, v_j)$必然属于最小生成树. 否则, 这个生成树肯定不是最小的. 

\subsection*{闲聊与练习}

\begin{exercise}{Floyd算法原理的简单应用}
    \ti{P6175 无向图的最小环问题}
    
\end{exercise}
\part{动态规划简介}

这一部分我们继续跟随状态机的模型, 探求问题的状态, 用一种比较聪明的方法来说明
如何比较聪明地遍历问题. 

\section{初步的问题}

\lec{数字三角形}{介绍} TBD: 数字三角形的相关内容请参考

这是一个耳熟能详的问题. 不过一个问题需要仔细地考虑: 为什么方程
$d[i][j]=a[i][j]+\max(d[i+1][j], d[i+1][j+1])$的后半段直接可以取最大值? 
事实上, 我们发现这是我们要求最大决定的 -- 如果连``从$(i+1,j)$''出发走到底部
的和都不是最大的, 加上$a[i][j]$之后也肯定不是最大的. 这个性质被称为\textbf{最优子结构
(optimal structure)}. 有``全局的最优解包含着局部的最优解''的想法. 具体如何
进行, 我们可以先使用搜索试试看, 之后分析出状态转移的规律, 就可以使用迭代的方式
进行实现了. 

我们来看下面的问题: 

\ti{P1004 方格取数} 想法1: 我会搜索! 我希望暴力枚举出所有可能的情况. 

上述做法直接解决了一整个大问题. 但是在解决的时候可能会出现一些重叠的子问题. 并不
太好. 我们想一想可以如何称为若干个子问题. 第一个想法是定义$f[i][j]$表示从(0,0)
走到$(i,j)$的过程. 这样可行吗? 看上去不行, 因为我们没有记录重复的数 - 重复的数是
没有办法再取的. 

那么走两次, 我们可以这样设计: $f[i_1][j_1][i_2][j_2]$表示所有从$(1,1),(1,1)$
走到$(i_1,j_1),(i_2,j_2)$的路径的最大值. 如何处理同一个格子被取两遍的呢? 只需要
保证当前处理的时候不相同即可. 

这里有4种情况, 因为每一个都可以从上来和从左来. 我们从最后一步考虑, 有如下的四类情况
TBD: 一个集合关系, 下下, 下右, 右下, 右右 直接判定即可. 
\file{1004-4D}

我们还可以把这个优化: 由于只能向下, 向右走, 不能走回头路, 当
$i_1+j_1 = i_2 +j_2$的时候, 格子才可能重合. 

\lec{充分条件和必要条件}{简介} 这里面, 我们说只有满足这个条件才可能重合, 
意味着只要重合了就一定会满足这个条件. 但是, $i_1+j_1 = i_2 +j_2$
无法推出一定重合. 我们就说他们``重合''是$i_1+j_1 = i_2 +j_2$的
\textbf{充分(sufficent)条件}, 
$i_1+j_1 = i_2 +j_2$是他们``重合''的\textbf{必要(necessary)条件}. 或者用
符号表示, 是这样的: ``($i_1+j_1 = i_2 +j_2)\Leftarrow$ 重合''. 

由于有一个等式了, 我们可以``消掉''一个量. 我们提出一种更加简化的方法:
让$k=i_1+j_1=i_2+j_2$.  
$f[k, i_1, i_2]$表示所有从$(1,1), (1,1)$到$(i_1, k-i_1), (i_2, k-i_2)$
路径的最大值. 

看上去这会让我们的转移方程难以写. 但经过分析, 也是可以做到的, 根据图, 有如下的四类情况
\begin{itemize}
    \item 下下: 从$f[k-1][i_1-1][i_2-1]$, 重合加上$w[i_1][j_1]$, 不重合加上$w[i_1][j_1]+w[i_2][j_2]$.
    \item ...
\end{itemize}

其实也没什么大不了, 只是把刚刚的状态浓缩到了$k$里面. 下面我们来看代码 \file{1004-3D}

\lec{技巧}{缩减编码复杂度} 事实上, 调代码是非常折磨人的. 如果我们能写出易于
检查的代码就好了. 这里面, 我们想把\codeword{f[k][i1][i2]}所减掉, 有没有什么
办法呢? 其实有两种办法: 第一种是使用引用: 输入
\codeword{int &x = f[k][i1][i2];} 这样下次使用的时候\codeword{x}就相当于
\codeword{f[k][x1][x2]}了. 另外一个可以使用\codeword{\#define}关键字. 
不过记得使用\codeword{\#undef}取消宏定义在使用结束的时候. 第一种情况用的很多. 

\begin{remark}
    编写易于理解, 不言自明的代码有些时候是保持思维逻辑清楚的很重要的一个习惯. 每当
    我们面临一个困难的问题的时候, 我们可以想一想有没有什么方法简化它. jyy
    老师在\href{https://zhuanlan.zhihu.com/p/619237809}{这篇文章}说过这样的一段话: 
    ``有个小朋友 Segmentation Fault 了也不知道哪里来的自信, 
    一口咬定是机器的问题. 给他换了机器, 并且教育了他机器永远是对的. 
    这个小插曲体现了编程的基础教育还有很大的缺憾, 使得竞赛选手大多都缺少真正的`编程' 训练,
    我看他们对着那长得要命的 \codeword{if (...dp[a][b][c][d][e][f][n^1]...)} 
    调的真叫一个累. 让我不由得想起若干年前某 NOI 金牌选手在某题爆零后对着一行有 20 
    个括号的代码哭的场景. '' 
\end{remark}


\ti{P1006 传纸条} 传纸条和上一个问题基本是类似的. 双倍经验的时间来了. 


\lec{DP的多重视角}{状态集合的角度} 我们可以用如下的检查单来思考一个(可能的)
动态规划问题. 因此, 我们可以把在这个属性下具有相同特征的内容划分为若干个
集合, 然后根据每一个划分, 找到相应的规律, 就可以得到对应的结果了. 

\begin{theorem}
    在思考动态规划问题的时候, 可以采用以下的检查单: 
    
    A. 状态表示:

        (1) 我状态表示归类的是哪一类的问题? 

        (2) 要在这一类问题上体现哪些属性? 

    B. 状态计算

        (1) 当前状态可以由哪些状态得来?

        (2) 对于这些内容, 这个属性前后的关系是什么? 
    
\end{theorem}

\lec{DP的多重视角}{DFS的视角} 有时候, 如果我们的递推关系过于奇怪, 我们可以
回到我们的老本行, 写出\textbf{没有额外变量}的dfs程序, 然后使用数组来递推. 
由于我们的函数调用关系, 这个依赖关系是在调用的时候就能够轻松做出来的. 由于
子问题有重叠, 每次我们只要把一个子问题计算一遍存起来就好了. 

记忆化搜索和递推二者都确保了同一状态至多只被求解一次. 但是它们实现这一点
的方式则略有不同: 递推通过设置明确的访问顺序来避免重复访问, 
记忆化搜索虽然没有明确规定访问顺序, 但通过给已经访问过的状态打标记的方式, 
同样达到了的目的. 

与递推相比, 记忆化搜索因为不用明确规定访问顺序, 在实现难度上有时低于递推. 
且能比较方便地处理边界情况. 但与此同时, 记忆化搜索难以使用一些更加聪明的优化
方式, 我们在接下来的背包问题中可以看到一些. 


接下来我们来看几个类似的问题. 

\lec{最长上升子序列问题}{简介} 我们现在考察最长上升子序列(LCS)的问题. 根据我们的
检查单, 我们决定定义状态$f[i]$表示集合
$a[i]$表示以$a[i]$为结尾的严格单调上升子序列. 要维护的属性
是最大值. 现在我们考虑所有到达了$f[i]$的内容. 看看它可以从哪来: 

TBD: 加一个图示

分析了上面的内容, 我们就可以发现状态转移方程为 
$$f[i] = \max \{f[k]\} +1, \forall k\in [1..i-1], f[k]<f[i].$$

上升子序列给我们的感受是往上升. 那么下面我们来看一个既有上升又有下降的内容. 

\ti{\href{https://vjudge.net/problem/OpenJ_Bailian-2995}{登山}} 
我们可以按照中间是哪个点是最高点分析. 先分为
$a[0],a[1], a[2],\cdots, a[n-1], a[n]$是山峰这几类. 我们分别求出每一类的
长度最大值就是整个的最大值. 不是一般性, 如果峰值是第$k$个的最大长度, 并且左边选
哪些和右边的情况互不相干, 那么就在左边和右边分别跑一下LCS问题, 然后找到$\max$就行
了. 

在做模拟题的时候, 我们可能留意了``合唱队形(NOIP)''这个问题. 其实, 这个是一个对偶.
去掉多少人就是总数减去留下多少人. 

\begin{remark}
    对偶问题. 我们说两个问题是对偶的, 感觉上就是两个问题表达的是
    一个问题的两个方面. 或者更直观的说, 有一种对称性. 例如这个问题
    和合唱队形的问题; 到未来大家学习最大流和最小割, 他们都具有对偶的
    感受. 
\end{remark}

\ti{P2782 友好城市} 这里的要求是不交叉. 我们发现我们要求的序关系消失了. 
我们考察所有合法的建桥方式和上升子序列之间的联系: 对于任何一个合法的建桥方式, 
从一侧观察一边的点, 另一边都是严格上升的. 对于任意一个严格上升的子序列, 我们都
能够找到合法的架桥方式. 也就是他们之间构成双射. 所以我们按照自变量大小进行排序
看因变量的LCS就好了. 

其实, 没有交叉意味着没有逆序对. 如果你曾经实现过归并排序, 你一定对这个不会陌生. 

\lec{映射}{表达关系} 将给定集合的每个元素与另一个集合的一个或多个元素相关联的
一种思想. 我们在刚刚的问题里面发现了一对一的这样的情况, 因此可以断定两个问题
的大小是一样的. 

\lec{最大上升子序列}{之和} 这次, 我们想要知道你挑选出来的上升子序列里面, 其和
是多少. 你会发现, 最长上升子序列并不意味着最大的和. 我们又要按照刚刚的方法分析
了.  状态$f[i]$表示所有以$a[i]$为结尾的上升子序列, 属性是和的最大值. 状态
计算的划分是可以划分为上一个数字选的是空, $a[1], \cdots, a[i-1]$. 于是, 
我们就得出了状态转移方程: 

$$f[i] = \max \{f[k]+a[i]\} +, \forall k\in [1..i-1], f[k]<f[i]$$ 

\ti{\href{https://vjudge.net/problem/OpenJ_NOI-CH0206-8462}{大盗阿福}} 
直觉来看, 我们想要设置$f(i)$代表当前抢劫到了第$i$个店铺的最大收益. 于是, 当前
的状态被划分为两块: 抢劫第$i$家店铺, 得到$f[i-2]+w[i]$, 以及不抢劫
第$i$家店铺. 于是, 我们得到状态的转移方程为$f[i]=\max(f[i-2]+w[i], f[i-1]).$

这个状态需要依赖上面两维的状态. 如果我们只希望依赖上面一维的状态, 
我们还需要增加一维: 用$f(i, 1)$表示上一家
店铺被抢了, $f(i, 0)$表示上一家店铺没有抢. 因此, 我们就可以转移了. 

这种转移有一些头疼. 于是, 我们可以使用一个特殊的方法 - 请看

TBD: 状态图 % 1 loop 0 to 1 1 to 0

我们下面来正式把这个说一说: 定义$f(i,0)$表示当前站在第$i$个建筑前面, 当前
状态位于$j$的所有走法, 得到的最大值. 下面决定状态转移方程. 考虑$f[i][0]$, 
有哪些走法可以走到0? 其实, 我们可以从上一个0走到0; 或者从1走到0. 因此, 
它们的最大值分别是$f[i-1][0]$和$f[i-1][1]$ - 毕竟没有选择这家店铺. 
下面考虑$f[i][1]$. 我们只能从$f[i-1][0]$走过来. 这样子, 获得的收益是
$f[i-1][0] + w[i]$. 综合去取$\max$即可. 图示如下:

TBD: 图示

\ti{\href{https://www.luogu.com.cn/problem/T294782}{最长公共上升子序列}} 这个问题
我们定义状态$f[i][j]$为所有由第一个序列的前$i$个字母, 第二个序列的前$j$个字母构成的
公共上升子序列, 属性是要求最长的. 但是我们发现在转移的时候因为缺少条件, 我们还需要
知道现在结尾的数是多少, 以便于我们判断是不是可以向后增加. 具体地, 我们这样修改我们的
定义: ``状态$f[i][j]$为所有由第一个序列的前$i$个字母, 第二个序列的前$j$个字母构成的
公共上升子序列, 并且有$b[j]$结尾''. 

那么, 有哪些状态可以转移到了$f[i][j]$呢? 我们可以包含两类: 所有包含$a[i]$的 
公共上升子序列, 另外的是左右不包含$a[i]$的公共上升子序列. 第二类里面, 由于它最后不包含
第$i$个字母, 说明它只可能包含前$i-1$个字母. 即从状态$f[i-1][j]$转移来. 那第一类呢? 
根据状态的定义, 由于同时包含$a[i]$和$b[j]$. 由于$a[i]$是不确定发的, 我们需要继续细分, 
就像刚刚的LCS问题一样. 我们考虑序列的倒数第二个数. 有可能是空, 
$b[1], b[2], \cdots, b[j-1]$. 这样一来, 我们就从实际意义出发, 发现如果是$b[k]$作为
倒数第二个字符的话, 那么值应该是$f[i][k]+1$. 不过这个DP问题可能还需要对代码做等价变形, 
我们来看一看: TBD

现在我们做代码的等价变形, 可以TBD. 

\begin{remark}
    一个问题, 尤其是困难的问题, 搞清楚来龙去脉是重要的. 任何感觉到难的内容可能只是
    缺乏了前置应该了解的东西. 所以, 很多时候, 看一看它的历史, 你就能知道更加多样
    的东西. 甚至追寻着历史的规律, 有一天你也能为解决这一类问题添砖加瓦! 
\end{remark}

\ti{{股票买卖}} 题目叙述: 给一个长度为$N(1\leq N \leq 10^5)$的数组, 数组中的第$i$数字表示给定股票在
第$i$天的价格. 设计一个算法计算能获取的最大利润, 最多完成$k$笔交易. 你不能同时参与多笔交易( 你必须在再次购买前出售掉之前的股票) .
一次买入卖出合为一笔交易. 第一行包含整数$N,k(1\leq k\leq 100)$, 表示数组长度和最大交易数, 第二行$N$个
不超过10000的正整数, 表示完整的数组. 输出一个整数, 表示最大利润. 

我们发现在例子的情况下, 我们能进行的操作是``买入''和``卖出''. 造成结果是``手中有股''
和``手中无股票''. 这下子, 我们发现最好按照这样的划分方法, 才可以把原来的内容描述
清楚. 如果我们手中有货, 我们在下一天到来的时候既可以继续持有, 或者卖出, 同时得到
一定的收益(得到$w[i]$); 
如果我们手中无货, 那么下一天到来的时候, 我们可以买入 (并付出$w[i]$), 
或者按兵不动. 

我们效仿背包的情况: 假设现在进行到了第$i$天, 正在进行第$j$笔交易(买入就算做这笔交易), 有
$f[i][j][0]=\max(f[i-1][j][0], f[i-1][j-1][1]+w[i])$. 同样的有 
$f[i][j][1]=\max(f[i-1][j][1], f[i-1][j-1][0]-w[i])$. 

\begin{ques}
    如果卖出的时候, 使用了这个会导致全局最大值不对吗? 
\end{ques}

我们会遍历所有的空间, 正如我们前面所说, 这是一个``聪明的搜索'', 所有的状态都会被
计算到的. 

\ti{{\href{https://www.luogu.com.cn/problem/U298750}{股票买卖2}}}
我们这时候发现状态影响决策有手中有货, 手中无货的第一天, 以及手中无货大于等于
第二条(冷冻期). 

TBD: 状态图 手中有货转圈圈(0), 有货->手中无货第一天(+w[i]), 手中无货1->无货的第二天(0) 
手中无货转圈圈(0), 手中无货2->手中有货(-w[i]). 出口有两个

转移方程, 根据上图就有: $f[i][0] = \max(f[i-1][0], f[i-1][2]-w[i])$; 
$f[i][1]=f[i-1][0]+w[i]$, 以及$f[i][2]=\max(f[i-1][1],f[i-1][2])$. 

运用状态机的视角真不错. 我们在很多时候在处理很多问题的时候也可以这样做. 

\section{背包问题} 

背包问题是一类很经典的问题. 我们首先介绍一些常见的策略, 然后仔细看一看
``0-1背包问题''. 背包问题选出的内容里面没有内在的关系. 有时候可以成为组合
类的DP. 

\lec{0-1背包问题}{简介} 假设你是一个背包客, 要去旅行, 但是你只能带一只背包. 
现在的问题是, 你面前有一些物品, 每个物品都有自己的重量和价值. 
你希望在背包的承重范围内尽可能装入最有价值的物品. 

然而, 你的背包有个限制: 
它只能承受一定重量的物品, 超过这个限制它就会撑破了. 所以你必须仔细考虑, 该怎样选择物品放进背包. 

这就是所谓的0-1背包问题: 你要在一系列物品中做出选择, 每个物品只有一个 (0个或1个) 存在的机会. 
你不能切割物品, 只能选择全部放入或不放入. 

\ti{P1048 采药} 这是一个最为普通的背包问题. 我们现在考虑如何设计方案, 以及有什么
好的办法来做这件事情. 我们设计状态$f[i][j]$表示在集合``考虑前$i$个物品, 总容量
为$j$''的价值的最大值. 那么根据最后一步, 可以把状态表示转化为两大类 - 要么选择第$i$个
要么不选第$i$个. 

不选的方案的话, 那么是$f[i-1][j]$, 如果选取的话, 那么有分为
之前的加上第$i$个. $f[i-1][j-v[i]]+w[i]$. 我们只要找到他们的最大值就好了. 
请看代码\file{P1048-2D}. 

下面我们来看他是如何转移的. 我们发现, 如果我们采用倒序的方式循环的话, 就可以被压缩到一维了. 
请看代码参考\file{P1048-1D}

\lec{完全背包问题}{介绍} 假设我们所有的这些内容都有无限件可以选呢? 这时候我们就可以
同样定义$f[i][j]$为所有只从前$i$个物品中选, 且总体积不超过$j$的选法的集合. 要维护的属性
同样是最大值. 下面我们来看状态的计算. 既然我们可以选0,1,2,$\cdots, s-1, s$个, 那么就需要
分别对于这个进行转移了. 选0个就是$f[i-1][j]$; 选1个就是$f[i-1][j-v[i]]+w[i]$;
选2个就是$f[i-1][j-2\times v[i]]+2\times w[i]$, $\cdots$. 
按照道理来讲, 这个可以写作代码了. 我们可以第一层枚举物品, 第二层枚举体积, 第三层枚举选多少个. 
如\file{complete-bp-primary}

我们来看一看有没有优化的空间. 我们观察到$f[i][j]$的表达式
$$
f[i][j] = \max(f[i-1][j], f[i-1][j-v]+w, f[i-1][j-2v]+2w, \cdots, f[i-1][j-sv]+sw)
$$
与$f[i][j-v]$的表达式有时候类似, 把$j$换为$j-v$即可: 
$$
f[i][j] = \max(\qquad ~~~f[i-1][j-v], f[i-1][j-2v]+w, f[i-1][j-3v]+2w, \cdots, f[i-1][j-sv]+(s-1)w)
$$
注意这里的$s$的表达式是不依赖于$v$的, 并且$s=\lceil j/v \rceil$. 

我们发现上面的项和下面的是可以对齐的, 他们之间有很多的性质. 比如, 下面的每一项比上面的每一项少了
一个$w$, 因此上面的最大值等于下面的最大值加上$w$. 于是$f[i][j]$的值就可以替换做
$$
f[i][j] = \max(f[i][j], f[i][j-v]+w).
$$

这就是我们得到的最终表达式. 同样可以优化为1维的, 只要把体积的枚举的顺序改为顺序的循环就行了. 
事实上, 当空间优化为1维的时候, 只有完全背包由于无限的关系, 需要从小到大循环. 我们可以使用
\file{complete-bp-1d}来看一看. 其中$v[i]$是重量, $w[i]$是价值. 

\lec{多重背包问题}{一个困难的做法} 多重背包是每一个里面有有限个物品的问题. 遵循刚刚的, 如果某一个物品有
$s$件, 那么转移方程就有
$$
f[i][j] = \max(f[i-1][j], f[i-1][j-v]+w, f[i-1][j-2v]+2w, \cdots, f[i-1][j-sv]+sw).
$$
同样的, 我们现在来看一看$f[i][j-v]$是什么: 
$$
f[i][j-v] = \max(\qquad ~~~ f[i-1][j-v], f[i-1][j-2v]+w, f[i-1][j-3v]+2w, \cdots, f[i-1][j-(s+1)v]+sw).
$$

唯一不同的地方是最后一项都是一样的, 并且上面的比下面的每一项多一个$w$. 但是关键不同是最后
多了一项. 我们的目标是求上面的最大值; 但是我们并不能根据下面的反推上面的最大值的. 那么, 
我们再看一项: 
\begin{align*}
    f[i][j-2v] &= \max(f[i-1][j-2v], f[i-1][j-3v]+w, f[i-1][j-4v]+2w, \cdots, f[i-1][j-(s+2)v]+sw)\\
    f[i][j-3v] &= \max(f[i-1][j-3v], f[i-1][j-4v]+w, f[i-1][j-5v]+2w, \cdots, f[i-1][j-(s+3)v]+sw)\\
    \cdots
\end{align*}
注意到$j-kv$是模$v$余数相同的, 于是考虑画一个数轴来看一看所有的情况. TBD
也就是每一个需要用到前面的几个状态的最大值, 这个就可以用滑动窗口解决了. 请看代码\file{mulbp-deq}

\lec{多重背包问题}{拆分为0-1背包} 下面的这个思路就比较简单了. 可以把它拆分成0-1背包问题, 再使用
0-1背包的模板做就好了. 不过这里的划分也是有技巧的, 我们可以使用以前倍增介绍的一个方法, 按照二进制
拆分. 如\file{mulbp-bin}. 

下面我们来看上面介绍的一些对应的习题. 

\ti{P1049 装箱问题} 这里面没有了``价值''. 怎么做? 其实体积同时也是价值, 然后用0-1背包求解
就可以了. 请看\file{P1049}

\lec{二维费用的背包问题}{简介} 有时候我们的体积可能是二维的, 我们来看下面的例子: 

\ti{\href{https://vjudge.net/problem/OpenJ_Bailian-4102}{宠物小精灵之收服}} 这下子, 
费用变为二维的了. 费用之一是精灵球数量, 之二是皮卡丘的体力值; 价值就是小精灵的数量. 首先考虑状态
表示, 定义$f[i][j][k]$表示从前$i$个物品中选, 且花费1不超过$j$, 花费2不超过 $k$的选法中, 最大
的价值. 那么$f[i][j][k] = \max\{f[i-1][j][k], f[i-1][j-v_1[i]][k-v_2[i]]+1\}$. 当我们
把所有状态都算过了之后, 得到答案的时候就可以收服$f[k][N][M]$个精灵. 最少耗费的体力就看
$f[K][N][m]$的$m$最小是多少, 使得我们可以等于最大值. \file{2dcost} 
(所有的体积维度都是倒着循环的, 可以发现)

\ti{\href{https://www.luogu.com.cn/problem/U291791}{潜水员}} 这个问题类似于上面的问题. 
但是也有一些变动. 我们定义为
$f[i][j][k]$表示从前$i$个物品中选, 且花费1\textbf{恰好是}$j$, 花费2\textbf{恰好是}$k$的选法中, 最小的
价值. 那么$f[i][j][k] = \max\{f[i-1][j][k], f[i-1][j-v_1[i]][k-v_2[i]]+1\}$. 之后, 
枚举$j\geq m, k\geq n$的里面找一个最小值就可以了. 对应到代码上面, 我们只需要按照实际的含义
把$f[0][0][0]=0$, 其余是$f[0][j][k]=+\infty$, 表示不合法 -- 毕竟到不了.  \file{U291791}

\lec{背包的方案数}{简介} \ti{\href{https://vjudge.net/problem/OpenJ_Bailian-4004}{数字组合}}
我们定义状态表示$f[i][j]$为所有只从前$i$个物品中选取, 且总体积恰好是
$j$的方案的集合. 属性是方案数. 那么考虑不包含物品$i$的所有选法, 为$f[i-1][j]$, 以及包括
物品$i$的所有选法, 就是$f[i][j] = f[i-1][j]+f[i-1][j-v_i]$. \file{BL4004}

\lec{分组背包}{简介} \ti{\href{https://www.acwing.com/problem/content/9/}{分组背包问题}}

这下, 每一次是能从一个物品组内最多选择一个物品. 剩下的就和原来的一样了. 这样子, 定义$f[i][j]$定义
为只考虑前$i$个组内总体积不超过$j$的, 划分的方案依据是从当前的这个内选哪个物品. 如第0个, 第1个,
$\cdots$, 第$s_i$个. 因此转移方程就是
$$
f[i][j] = \max(f[i-1][j-v_{i,1}]+w_{i,1}, f[i-1][j-v_{i,2}]+_{i,2}+\cdots + f[i-1][j-v_{i,s}]+_{i,s})
$$
和0-1背包一样, 照样可以去掉第一维. 我们的做法如下: \file{grouping}

\ti{P1064 金明的预算方案} 这个本质上是一个分组背包的问题, 把每一个主件和附件的组合当做一个组, 
每一个组里面有一些选择: 购买主件; 购买主件和附件(所有的排列); 这样就是说有若干个物品组, 每个物品组
里面的每一个物品是当前的决策, 并且是互斥的. 然后使用分组背包的方法得到一个最大价值.  

\lec{树上的背包}{简介} 上面的问题如果可以由很多个子节点呢? 这就扩展为了树上的有依赖的
背包问题了. 下面我们来看一例: 

\ti{P2014} 我们首先定义状态, 我们可以使用递归的思路来解决这个问题. 我们会想, 对于这个点而言
不同的体积的时候得到的最大的价值是多少呢? 比如这个点是点$u$, 要求以$u$为根的时候在不同的体积
之下, 最大的价值是多少. 于是我们定义$f[u][j]$表示所有以$u$为根节点的子树中选取, 且总体积不
超过$j$的方案数中, 获得的最大的. 

接着来看如何做. 肯定, 要想选子树, 这个当前的根节点一定是要选的. 但是它的子节点就不一样了. 
对于$f[u][j]$的任何一个方案, 可以分为方案: (1) 从第一棵子树中选取的方案, (2) 从第二棵子树中选取的方案,...,
($m$) 从第$m$棵子树中选取的方案
每一棵子树每部也可以通过体积去划分.(不按照方案划分是因为代价太大了) 这样子, 我们就可以按照分组背包的方式
循环一遍. 用这样的方法我们就把诸多的一类问题用一个状态表示了. 

更通用的问题如下: \file{tree-bp}




\section{关于区间的问题}

有些动态规划问题, 我们设计状态需要考察一个区间. 我们从石子合并这个经典问题开始看起. 

\ti{P1775 石子合并(弱化版)} 假设这时候我们认为这是在一条链上的情形. 也就是不能首尾合并.
这时候, 我们定义$f[i][j]$表示所有从$i$到$j$合并的方案, 
属性是最小值. 下面我们来考虑状态的计算问题. 我们来看一看哪个可以到达这个状态. 
我们考虑合并两个区间, 会发现它的分界点不同. 所以这就启发我们使用不同的分界点去
划分现在的集合. 假设分界线落在$k$和$k+1$之间, 那么它需要的体力最小值就是
$f[l][k]+f[k][j]+\text{左右两边的和}$, 也就是先合并左边, 再合右边, 最后就把
两堆合在一起.  最后的是所有的子集的最小值. 状态转移很好写, 但是\textbf{注意循环顺序!}

转移方程: $f[i][j] = \min\{f[i][k]+f[k+1][j]+\sum_{s=i}^j a[i]\}$. 其中$k$从
$i$枚举到$j-1$. 状态空间是$n^2$, 需要枚举起点, 有$\mathcal O(n)$, 总共时间复杂度是
$\mathcal O(n^3)$. 计算$300^3=2.7\times 10^7$, 完全可以. 

接下来我们来看代码: \textbf{请留意循环顺序! } 按照区间长度从小到大枚举. \file{P1775}

从上面的代码中, 一般而言, 区间DP可以首先循环长度, 然后循环左端点, 之后算右端点, 最后枚举
分界点. 这样是使用循环去遍历状态. 正如我们前面所说, 我们也可以使用记忆化搜索的方法
写这个内容, 当转移不明确的时候. 

\begin{ques}
    如果每次允许合并相邻的$n$堆, 应该如何做? 说一说大致思路. 
\end{ques}

我们接下来的问题可以设置状态为前$i$个数成了$j$个的过程. 这相当于DP里面套了一层DP. 
我们这里不做讨论. 

\ti{P1880 石子合并} 下面我们来考虑环形的状况. 我们如何把环的情况展开成一条区间呢? 
因为环形剪掉一条边就成了一个链, 一个朴素的想法是我们
可以枚举缺口在哪. 就可以用区间DP的方法做了. 但这样的时间复杂度是$\mathcal O(n^4)$,
难以接受. 下面介绍一种优化方式: 

我们本质上是$n$个长度为$n$个链的式子合并问题. 我们可以这样做: TBD

这样一来, 我们使用长度为$2n$的区间, 就能保证我们只处理$n$个区间就可以枚举到所有的情况了. 
这样我们的复杂度是$\mathcal O((2n)^3)$. 这样的方法可以处理大多数的环形DP问题. 

请参看代码\file{P1880}. 

\ti{P1063 能量项链} 我们现在断环为链, 像上一个问题一样. 对于一个链, 我们定义状态的表示
$f[i][j]$为所有将$i..j$区间合并成为一个珠子的方式. 属性是维护最大值. 接着来看
合并的时候状态的计算. 我们来看一看哪个可以到达这个状态, 根据最后的不同点来划分. 
这个和上一个是类似的: 有一个分界线(在原来数组的视角下注意这时候是共用的). 根据这个
我们可以把集合划分为若干个子集. 其中分界线分别为$i+1, i+2, \cdots, r-2, r-1$.
假设当前的分界线是$k$的话, 那么就会有将$(i, k), (k, j)$最后将两个合并释放的能量. 
用数学公式写出来就是$f[i][k] + f[k][j] + w[l]\times w[k]\times w[r]$. 
这就是我们使用线性的做法, 现在我们考虑环形的. 运用上一个问题的技巧, 在后面一个$2n$的
链上面做DP就可以了. \file{P1062}

\ti{LOJP10149. \href{https://loj.ac/p/10149}{凸多边形的划分}} 这个问题需要我们一定的观察
与思考. 我们首先发现, 任意作一个三角形, 它就会把左边的和右边的三角形划分开. 因为题目
中有一个重要的条件 -- 互不相交. 这就保证了区间左右的独立性. 所有这样的方案把整个
内容分为了独立的三部分. 这是区间问题里面很重要的一个特征. 我们只要在这个状态下左半边
的划分, 右半边的划分和的最大值, 就可得到和上一个问题一样的想法. 也就是比如我要考虑
从1到$n$的划分, 中间选了点$k$作为分界点, 就有
$f[1][k]+f[k][n]+w[1]\times w[k] \times w[n]$. 我们来求每一个它们的最小值
就可以了. 这一个问题虽然和上一个问题构造非常不同, 但是其转移也非常的相似. 下面我们
详细看一下这个应该如何正式化: 

定义$f[l][r]$维护集合所有将$(l,l+1), (l+1, l+2), \cdots , (r-1, r), (r,l)$
划分为三角形的方案的值的最大值. 在进行状态计算的时候, 我们枚举$l+1, l+2,\cdots, r-2,
r-1$, 就可以把问题分为若干类. 对于每一类, 其转移到当前的值为$f[l][k]+f[k][r]+w[l]*w[k]*w[r]$.

很烦人的地方是, 这个问题需要写高精度. 因为$(10^9)^3\times100$大概会有30位数. 
\codeword{int}的最大值是2147483647, 9位数; \codeword{long long}的最大值是 
9223372036854775808, 19位数.  
我们应该秉持先做对, 再做好的原则进行. 也就是
先做对, 把样例和小测试数据做好, 然后再用高精度写剩余的部分. 
不加高精度的部分如\file{LOJP10149-part}所示. 

下面加上高精度. 为了方便起见我们直接用这个数组存位数, 直接整合进$f$数组里面. 
请看代码的\codeword{add}部分和\codeword{mul}部分. \file{LOJP10149}

\ti{P1040 加分二叉树} 我们看到这个问题, 发现其计算公式很像区间DP的计算的方式: 
分为三个独立的部分. 关键是, 这个中序遍历是不是具有这样的形式, 使得我们可以在上面
做区间DP呢? 

回顾: 现在有一棵树的中序遍历, 我们考察任意的一个子树, 可以发现其在序列里面一定是
连续的一段. 这就让我们可以进行选取根节点进行中序遍历. 我们定义$f[l][r]$为所有将
$l..r$区间构造成一个二叉树的情形. 属性是维护所有二叉树的最大值. 我们找到最后一个
不同点, 根据这些类划分为不同的集合. 我们按照根节点的位置划分. 这样就划分为了若干类.

和上面的问题一样, 如果根节点在第$k$个点的话, 最大值应该如何求? 应该是
$f[l][k-1]\times f[k+1][r]+w[k]$. 下面考虑应该如何记录方案. 

其实记录方案无非是决定最后在更新的时候再某个地方记上一笔: ``节点$k$已经成为了
这个子树的根.'' 于是定义 $g[l][r]$表示 $l..r$ 区间的根节点选哪个. 在输出
前序遍历的时候就先输出这里的根($g[1][n]=:R$)\sn{:=表示``定义做''. 冒号在被定义的表达式那一侧}
, 同时知道左子树的区间和柚子树区间
为$1..R-1, R+1..R$, 反复进行这个过程就行了. 

字典序最小的方案应该如何做? 实际上我们只要让根节点的值最小就好了. 也就是找到
最靠左的一个分界点. 只有在小于当前答案的时候才更新, 并且记录. 如\file{P1040}

我们看一看二维的区间DP. 这时候区间就看上去有点奇怪了. 

\ti{P5752 棋盘分割} 这里面看上去有一个陌生的统计量均方差, 不过不用担心. 
不过我们来看均方差的公式$\sigma = \sqrt{\sum_{i=1}^n(x_i-\overline{x}^2)
\over n}$, 要是想要这个带根号的最小, 就意味着可以求$\sigma^2$最小. 简单变形
就有: \sn{但其实我们可以不用变形的. 这里只是简单体会一下操纵求和记号.}
$$
    \begin{aligned}
        &~{\sum_{i=1}^{n} (x_i-\bar x)^2} \\
        &= \frac1n\sum_{i=1}^{n} (x_i^2-2x_i\bar x+\bar x^2) \\
        &= \frac1n \left(\sum_{i=1}^{n} x_i^2 - \bar x \sum_{i=1}^{n}2x_i + n\bar x^2\right)\\
        &= \frac1n \left(\sum_{i=1}^{n} x_i^2 - \bar x \cdot (2n\bar x) + n\bar x^2\right)\\
        &= \frac{\sum_{i=1}^n x_i^2}{n} - \bar x^2
    \end{aligned}
$$

\begin{remark}
    这个推导在概率论中是比较常见的. 
\end{remark}

这就是我们试图最小化的东西. 也就是所有部分平方和的最小值. 好, 下面我们来看动态规划部分.

定义$f[x_1][y_1][x_2][y_2][k]$表示子矩阵$(x_1, y_1), (x_2, y_2)$切分成
$k$不分的所有方案. 其中$x$是行, $y$是列. 维护的属性是$\sum_{i=1}^n(x_i-\overline{x}^2)$.
的最小值. 

接下来来看状态计算. 我们认为有沿着$x$轴切; 沿着$x$轴切. 一共各自有7种情况, 分别
选上面和下面的情况. 沿着$x$轴切有类似的情况. 
我们的目标是求每一类的最小值, 然后取$\min$. 对于每一类, 我们有上面继续切的分值, 
加上下面剩余的分值. 由于右边的和是固定的, 于是可以用二维的前缀和求出来. 最后求解就可以了. 

如果要用循环来实现, 那么会很复杂. 并且循环的顺序也可能一不留神写错. 这时候我们采用
记忆化搜索的方式完成本问题. \file{5752}

\section{树形DP}

下面我们把刚刚的这种思想扩展到树上, 看一看在树上会如何确定状态, 并且使用\codeword{dfs}
来自然地决定他们之间的转移. 

\ti{P1352 没有上司的舞会} 我们仍然使用前面的问题开始想起. 定义状态$f[u][0]$为 
从以$u$为根的这个子树中选择的方案, 但是不选$u$的方案; $f[u][1]$与之类似, 但是要
选择$u$的方案. 维护的属性是选择的点最大值. 接下来来看状态的计算. 如果要得到$f[u][0]$, 
先计算出来他们所有儿子的值$f[s_0][0], f[s_0][1], f[s_1][0], f[s_1][1],\cdots$. 
要想让整个最大, 那么我需要让所有的子树最大. 也就是
$f[u][0]=\max(f[s_0][0], f[s_0][1])+\max(f[s_1][0], f[s_1][1])+\cdots$.
那么$f[u][1]=h[u]+f[s_0][0]+f[s_1][0]+\cdots$. 这个一共有$2n$个状态, 需要枚举的是两个
儿子, 所以时间复杂度为$\mathcal O(n)$的. \file{P1352} 

\ti{树的直径} 给定一棵树, 树中包含$n$个节点, 编号为$1\sim n$和$n-1$条无向
边, 每条边有一个权值. 现在想找到树中的最长的直径. 

这次我们的边是无向边, 我们可以通过建立两条有向边的情况下来模拟无向边的情形. 下面考虑如何 
设计状态. 我们假设把所有的路径都枚举一遍, 在这些里面找到边的权重最大的. 我们先想着
把它分为若干类, 并在所有的进行取得max. 

首先随便找到一个点, 把它当做根节点. 我们在每条路径上面选择一个高度最高的点, 然后把
这个路径归到最高的点这个上面去. 我们按照这条路径上面最高的这个点去枚举, 似乎就会好
很多. 

那么如何进行状态的计算呢? 首先我们把所有的子节点的往下走的最大长度. 这个挂的点可以分为
两种情况: 第一种是一直往下走, 另一种是两个拼在一起, 也就是穿过了这条路径. 
第一种的计算方式就是往下走的最大
距离加上这条边的权值就行了. 第二种的计算方式, 就相当于是给我们了很多条边, 让我们在里面
任取两条, 使得拼出来的最大. 这样子我们肯定选最大的一个和次大的一个拼起来. 这就指示
我们用最大值和次大值相加得到这个问题的解答. 

如何求最大值和次大值呢? 我们可以使用一个循环的方式, 每次先更新最大值, 最大值更新了之后
把最大值给次大值就行了. 下面来看代码: 

注意搜索的时候不能向上搜索, 只能向下搜索, 否则会出现死循环. 于是dfs的时候可以加上一个参数
father. \file{diameter} 

如果是无权重的边, 有如下的算法亦可以做: 

\begin{itemize}
    \item 任取一点作为起点, 距离该点找一个最远的点$u$;
    \item 再找距离$u$最远的一点$v$, 此时, $u,v$之间的路径就是一条直径.
\end{itemize}

这个算法并不直观. 我们给出证明: 

\begin{proof}
    我们只要证明第一步找出的$u$一定是某个直径的起点. 假设任选一点$a$, 距离$a$
    最远的其中一点为$u$. 考虑反证法, 假设它不是一个直径的起点, 假设某一条真正的直径
    是$b\to c$. 我们现在按照此算法得到的直径与真正的直径有如下的几种情形: 

    (1) 两个直径是不相交的: 由于连通性, 从$a\to b$这条路径上面一定存在一个点可以
    (不一定是一步)走到$b\to c$这条路径上. 这条路径交于刚刚的两条路径为$x, y$. 
    由于$u$距离$a$最远, 因此$\text{dis}(x, u)\geq \text{dis}(x,y)+\text{dis}(y,c)$. 
    并且做移项并放大, 有$\text{dis}(x, u)+\text{dis}(x,y) \geq \text{dis}(y,c)$.
    那就说明, 沿着$y\to xto u$的距离一定是大于$y\to c$的距离, 所以更长的直径是
    $b\to y\to x\to u$. 因此, $u$一定是某一条直径的端点. 
    
    (2) 两个直径之间有公共的端点, 记作$x$: 由于$u$是距离$a$最远的一点, 那么
    $\text{dis}{(x,u)}\geq \text{dis}{(x, c)}$. 由于$b\to c$是一条直径, $\text{dis}(b,u)\geq \text{dis}(b,c)$
    因此$b\to u$是一个更长的直径, 我们的证明了$u$一定在某一个顶点上. 
    
\end{proof}

\ti{\href{https://www.luogu.com.cn/problem/U261056}{树的中心}}
题目大意: 给定一棵树, 树中有n个结点(结点编号为$1\sim n$)
, 请求出该树的中心结点的编号. 树的中心指的是, 该结点离树中的其他结点, 最远距离最近. $(n\leq 10^5)$

一个节点距离最远的有哪些类呢? 首先可以是往下走, 其次可以是往上走的. 往下走的倒是
很好说, 直接是刚刚存的\codeword{dist}; 但是往上走的就不一样了. 往上走的话, 又可以分为两类: 一类是接着往上走; 
另一类是往下走. 往下走又分为两类: 第一类是走过了当前点, 另一类是没有走过当前点. 

往下走的情况, 对于走过了当前点而言, 那就加上次大值(因为不能再走回去绕圈圈); 对于没有
走过这个点而言, 那就加上最大值构成这个点的最优情形. 请看\file{center-with-weight}.

对于本问题, 可以对上述代码稍加改动得到: \file{center-with-weight-outnum}.

\ti{\href{https://loj.ac/p/10155}{LOJ10155 数字转换}} 我们发现可以用图的观点来
建模这道题. 如果$x$可以转换为$y$, 那么就把$x, y$之间连一条边. 由于每个数的约数之和
是给定的, 那么每个点至多有一个父节点. 因此会得到一些树的集合(注意不一定是一棵). 所以我们在
这些树里面找到最长的路径就可以了. 

关于枚举因数之和, 我们可以先枚举一个数, 再枚举哪些数是它的倍数, 这样就会快一些. 
第一次要枚举$n$次, 第二次$n/2$次, 第三次$n/3$次. 于是总的枚举次数是
$$
n\left(1+\frac12 +\frac13+\cdots + \frac1n\right).
$$
里面的$\sum_{i=1}^{n} 1/i$, 当$n\to \infty$的时候, 这个渐进复杂度是$\ln n + \gamma$的
\mn{这是因为$1+1/2+\cdots+1/n -\ln n$在$n\to \infty$的时候是有极限的. 因为
有极限的其中之一原则是随着$n$增大, 数列单调递减, 并且有下界(不会走下某一个值). 
$\gamma$大约是0.57122左右, 称为Euler常数.}. 
因此, 这个时间复杂度是
$\ln$级别的. 剩下的细节请参看文件\file{LOJ10155}

\ti{\href{https://loj.ac/p/10153}{LOJ10153 二叉苹果树}} 我们定义$f[i][j]$为以$i$为根的子树里面选择
$j$条边的最大价值. 那么, 有哪些节点可以到达$f[i][j]$呢? 肯定是要从它的子节点中找线索. 也就是我们需要考虑
子节点(例如叫$s$), 选0个($f[s][0]+w$), 选1个($f[s][1]+w$), $\cdots$, 选$j-1$个($f[s][j-1]+w$, 留一个
给$j$). 

\ti{\href{https://www.luogu.com.cn/problem/P2016}{P2016 战略游戏}}我们定义$f[u][0]$表示为所有以
$u$为子树中, 且不设置的最小值; 定义$f[u][1]$是选择, 其余与$f[u][0]$一致. 下面我们来看状态的计算: 

有哪些来可以到这里呢? 
看$f[u][0]$: 注意到这一个集合的每一个方案都可以分成若干部分, 每一个部分代表每个子树. 根据每个子树的
选法, 因为他们是独立的, 我们可以拼凑出整个稍微大一点的树的选法. 想让整个最小, 要让每一部分别最小. 
所以就是$\min\{f[s_1][1],f[s_2][1],\cdots, f[s_n][1]\}$. 

如果是$f[u][1]$, 那么就选了这个点, 就可选可不选. 
那么就是$\min\{f[s_1][1],f[s_1][0],f[s_2][1],f[s_2][0],\cdots, f[s_n][1],f[s_n][0]\}$.

下面我们来看代码: \file{P2016}

\ti{\href{https://loj.ac/p/10157}{LOJ10157 皇宫看守}} 我们可以按照我们的需求来设计状态. 
一般来说, 就是看一看当前节点有哪些情形. 我们发现, (0) 它可以被父节点看到; (1) 它可能在子节点上面设置; (2) 它可以自己上面
就有一个士兵三种状态. 所以我们顺势设置三个状态: $f[i][0]$表示它可以被父节点看到所有摆放方案的最小花费; 
$f[i][1]$表示被子节点看到的所有摆放方案的最小花费, $f[i][2]$同理, 不过是在当前节点
摆放的左右方案的最小花费. 

考虑状态的计算: 第一种情况是$f[i][0]=\sum_{j\in i\text{'s son}}\min\{f[j][1], f[j][2]\}$; 
第二种情况是$f[i][2]=\sum_{j\in i\text{'s son}}\min\{f[j][0], f[j][1], f[j][2]\}$; 最后
一种情况是$f[i][1]$. 这种情形比较麻烦, 因为我们不知道是哪一个节点看到的这个节点. 因此
我们需要枚举出来放在哪一个上面去了, 取最小的出来. 也就是
$f[i][1]=\min_k \{f[k][2]+\sum_{j\neq k}\min \{f[j][1], f[j][2]\}\}$. (首先$k$放置
警卫, 然后再在其他点不放置)

具体实现细节请看代码\file{LP2016}. 

\section*{闲聊与练习}

\begin{quote}
    著名数学教育家应先生:听不懂比听懂好.

    著名竞赛教练、国家队教练冷老师:``反应慢是上天给你的礼物''.

    \hfill ---韩涛\mn{北大毕业,IMO金牌教练.学而思集训队(星队)创始人之一.
    数十位学生进入数学国家集训队, 2位学生获得IMO金牌.}, 在朋友圈的一条推文.  
\end{quote}

\begin{quote}
    终点固然令人向往, 这一路的风景更是美不胜收. 

    \hfill --- 魏恒峰, 在南京大学\href{https://www.bilibili.com/video/BV1K24y1u7eA}{编译原理}课上
\end{quote}

\begin{quote}
    状态合并么？你GET dp的本质了。实际上，如果你去看计数问题，相当多的dp都是
    找到一个好的特征，然后把集合划
    分成同构/存在某种数量映射关系的子集，然后只算少量几次。特征就是关键

    \hfill --- 蒋炎岩, 在一次聊天中
\end{quote}

\textbf{Takeaway Messages: }
\begin{itemize}
    \item (!) 知道了动态规划其实就是对于有\textbf{最优子结构(也就是我们一直在用最优的小问题试图拼最优的大问题)}问题设计的更聪明地枚举(设计好重叠的小情形);
    \item (!) 注意到了记忆数组和遍历顺序的重要性;
    \item 认识了不同种类的动态规划类型, 感受到了划分集合的重要性;
    \item 发现了其实和上一节一些计数问题的解决遵循相同的规则.
\end{itemize}

\centi{A组问题}

一. 回答下列小问题
\begin{itemize}[noitemsep]
    \item 简单使用动态规划解决问题的一些特征. 
    \item 使用迭代的方式和记忆化搜索的方式给你的感觉有什么相同和不同?
\end{itemize}
\part{动态规划简介}

这一部分我们继续跟随状态机的模型, 探求问题的状态, 用一种比较聪明的方法来说明
如何比较聪明地遍历问题. 

\section{初步的问题}

\lec{数字三角形}{介绍} TBD: 数字三角形的相关内容请参考

这是一个耳熟能详的问题. 不过一个问题需要仔细地考虑: 为什么方程
$d[i][j]=a[i][j]+\max(d[i+1][j], d[i+1][j+1])$的后半段直接可以取最大值? 
事实上, 我们发现这是我们要求最大决定的 -- 如果连``从$(i+1,j)$''出发走到底部
的和都不是最大的, 加上$a[i][j]$之后也肯定不是最大的. 这个性质被称为最优子结构
(optimal structure). 有``全局的最优解包含着局部的最优解''的想法. 具体如何
进行, 我们可以先使用搜索试试看, 之后分析出状态转移的规律, 就可以使用迭代的方式
进行实现了. 

我们来看下面的问题: 

\ti{P1004 方格取数} 想法1: 我会搜索! 我希望暴力枚举出所有可能的情况. 

上述做法直接解决了一整个大问题. 但是在解决的时候可能会出现一些重叠的子问题. 并不
太好. 我们想一想可以如何称为若干个子问题. 第一个想法是定义$f[i][j]$表示从(0,0)
走到$(i,j)$的过程. 这样可行吗? 看上去不行, 因为我们没有记录重复的数 - 重复的数是
没有办法再取的. 

那么走两次, 我们可以这样设计: $f[i_1][j_1][i_2][j_2]$表示所有从$(1,1),(1,1)$
走到$(i_1,j_1),(i_2,j_2)$的路径的最大值. 如何处理同一个格子被取两遍的呢? 只需要
保证当前处理的时候不相同即可. 

这里有4种情况, 因为每一个都可以从上来和从左来. 我们从最后一步考虑, 有如下的四类情况
TBD: 一个集合关系, 下下, 下右, 右下, 右右 直接判定即可. 
\file{1004-4D}

我们还可以把这个优化: 由于只能向下, 向右走, 不能走回头路, 当
$i_1+j_1 = i_2 +j_2$的时候, 格子才可能重合. 

\lec{充分条件和必要条件}{简介} 这里面, 我们说只有满足这个条件才可能重合, 
意味着只要重合了就一定会满足这个条件. 但是, $i_1+j_1 = i_2 +j_2$
无法推出一定重合. 我们就说他们``重合''是$i_1+j_1 = i_2 +j_2$的
\textbf{充分(sufficent)条件}, 
$i_1+j_1 = i_2 +j_2$是他们``重合''的\textbf{必要(necessary)条件}. 或者用
符号表示, 是这样的: ``($i_1+j_1 = i_2 +j_2)\Leftarrow$ 重合''. 

由于有一个等式了, 我们可以``消掉''一个量. 我们提出一种更加简化的方法:
让$k=i_1+j_1=i_2+j_2$.  
$f[k, i_1, i_2]$表示所有从$(1,1), (1,1)$到$(i_1, k-i_1), (i_2, k-i_2)$
路径的最大值. 

看上去这会让我们的转移方程难以写. 但经过分析, 也是可以做到的, 根据图, 有如下的四类情况
\begin{itemize}
    \item 下下: 从$f[k-1][i_1-1][i_2-1]$, 重合加上$w[i_1][j_1]$, 不重合加上$w[i_1][j_1]+w[i_2][j_2]$.
    \item ...
\end{itemize}

其实也没什么大不了, 只是把刚刚的状态浓缩到了$k$里面. 下面我们来看代码 \file{1004-3D}

\lec{技巧}{缩减编码复杂度} 事实上, 调代码是非常折磨人的. 如果我们能写出易于
检查的代码就好了. 这里面, 我们想把\codeword{f[k][i1][i2]}所减掉, 有没有什么
办法呢? 其实有两种办法: 第一种是使用引用: 输入
\codeword{int &x = f[k][i1][i2];} 这样下次使用的时候\codeword{x}就相当于
\codeword{f[k][x1][x2]}了. 另外一个可以使用\codeword{\#define}关键字. 
不过记得使用\codeword{\#undef}取消宏定义在使用结束的时候. 第一种情况用的很多. 

\begin{remark}
    编写易于理解, 不言自明的代码有些时候是保持思维逻辑清楚的很重要的一个习惯. 每当
    我们面临一个困难的问题的时候, 我们可以想一想有没有什么方法简化它. jyy
    老师在\href{https://zhuanlan.zhihu.com/p/619237809}{这篇文章}说过这样的一段话: 
    ``有个小朋友 Segmentation Fault 了也不知道哪里来的自信, 
    一口咬定是机器的问题. 给他换了机器, 并且教育了他机器永远是对的. 
    这个小插曲体现了编程的基础教育还有很大的缺憾, 使得竞赛选手大多都缺少真正的`编程' 训练,
    我看他们对着那长得要命的 \codeword{if (...dp[a][b][c][d][e][f][n^1]...)} 
    调的真叫一个累. 让我不由得想起若干年前某 NOI 金牌选手在某题爆零后对着一行有 20 
    个括号的代码哭的场景. '' 
\end{remark}


\ti{P1006 传纸条} 传纸条和上一个问题基本是类似的. 双倍经验的时间来了. 


\lec{DP的多重视角}{状态集合的角度} 我们可以用如下的检查单来思考一个(可能的)
动态规划问题. 因此, 我们可以把在这个属性下具有相同特征的内容划分为若干个
集合, 然后根据每一个划分, 找到相应的规律, 就可以得到对应的结果了. 

\begin{theorem}
    在思考动态规划问题的时候, 可以采用以下的检查单: 
    
    A. 状态表示:

        (1) 我状态表示归类的是哪一类的问题? 

        (2) 要在这一类问题上体现哪些属性? 

    B. 状态计算

        (1) 当前状态可以由哪些状态得来?

        (2) 对于这些内容, 这个属性前后的关系是什么? 
    
\end{theorem}

\lec{DP的多重视角}{DFS的视角} 有时候, 如果我们的递推关系过于奇怪, 我们可以
回到我们的老本行, 写出\textbf{没有额外变量}的dfs程序, 然后使用数组来递推. 
由于我们的函数调用关系, 这个依赖关系是在调用的时候就能够轻松做出来的. 由于
子问题有重叠, 每次我们只要把一个子问题计算一遍存起来就好了. 

记忆化搜索和递推二者都确保了同一状态至多只被求解一次. 但是它们实现这一点
的方式则略有不同: 递推通过设置明确的访问顺序来避免重复访问, 
记忆化搜索虽然没有明确规定访问顺序, 但通过给已经访问过的状态打标记的方式, 
同样达到了的目的。

与递推相比, 记忆化搜索因为不用明确规定访问顺序, 在实现难度上有时低于递推. 
且能比较方便地处理边界情况. 但与此同时, 记忆化搜索难以使用一些更加聪明的优化
方式, 我们在接下来的背包问题中可以看到一些. 


接下来我们来看几个类似的问题. 

\lec{最长上升子序列问题}{简介} 我们现在考察最长上升子序列(LCS)的问题. 根据我们的
检查单, 我们决定定义状态$f[i]$表示集合
$a[i]$表示以$a[i]$为结尾的严格单调上升子序列. 要维护的属性
是最大值. 现在我们考虑所有到达了$f[i]$的内容. 看看它可以从哪来: 

TBD: 加一个图示

分析了上面的内容, 我们就可以发现状态转移方程为 
$$f[i] = \max \{f[k]\} +1, \forall k\in [1..i-1], f[k]<f[i].$$

上升子序列给我们的感受是往上升. 那么下面我们来看一个既有上升又有下降的内容. 

\ti{\href{https://vjudge.net/problem/OpenJ_Bailian-2995}{登山}} 
我们可以按照中间是哪个点是最高点分析. 先分为
$a[0],a[1], a[2],\cdots, a[n-1], a[n]$是山峰这几类. 我们分别求出每一类的
长度最大值就是整个的最大值. 不是一般性, 如果峰值是第$k$个的最大长度, 并且左边选
哪些和右边的情况互不相干, 那么就在左边和右边分别跑一下LCS问题, 然后找到$\max$就行
了. 

在做模拟题的时候, 我们可能留意了``合唱队形(NOIP)''这个问题. 其实, 这个是一个对偶.
去掉多少人就是总数减去留下多少人. 

\begin{remark}
    对偶问题. 我们说两个问题是对偶的, 感觉上就是两个问题表达的是
    一个问题的两个方面. 或者更直观的说, 有一种对称性. 例如这个问题
    和合唱队形的问题; 到未来大家学习最大流和最小割, 他们都具有对偶的
    感受. 
\end{remark}

\ti{P2782 友好城市} 这里的要求是不交叉. 我们发现我们要求的序关系消失了. 
我们考察所有合法的建桥方式和上升子序列之间的联系: 对于任何一个合法的建桥方式, 
从一侧观察一边的点, 另一边都是严格上升的. 对于任意一个严格上升的子序列, 我们都
能够找到合法的架桥方式. 也就是他们之间构成双射. 所以我们按照自变量大小进行排序
看因变量的LCS就好了. 

其实, 没有交叉意味着没有逆序对. 如果你曾经实现过归并排序, 你一定对这个不会陌生. 

\lec{映射}{表达关系} 将给定集合的每个元素与另一个集合的一个或多个元素相关联的
一种思想. 我们在刚刚的问题里面发现了一对一的这样的情况, 因此可以断定两个问题
的大小是一样的. 

\lec{最大上升子序列}{之和} 这次, 我们想要知道你挑选出来的上升子序列里面, 其和
是多少. 你会发现, 最长上升子序列并不意味着最大的和. 我们又要按照刚刚的方法分析
了.  状态$f[i]$表示所有以$a[i]$为结尾的上升子序列, 属性是和的最大值. 状态
计算的划分是可以划分为上一个数字选的是空, $a[1], \cdots, a[i-1]$. 于是, 
我们就得出了状态转移方程: 

$$f[i] = \max \{f[k]+a[i]\} +, \forall k\in [1..i-1], f[k]<f[i]$$ 

\ti{\href{https://vjudge.net/problem/OpenJ_NOI-CH0206-8462}{大盗阿福}} 
直觉来看, 我们想要设置$f(i)$代表当前抢劫到了第$i$个店铺的最大收益. 于是, 当前
的状态被划分为两块: 抢劫第$i$家店铺, 得到$f[i-2]+w[i]$, 以及不抢劫
第$i$家店铺. 于是, 我们得到状态的转移方程为$f[i]=\max(f[i-2]+w[i], f[i-1]).$

这个状态需要依赖上面两维的状态. 如果我们只希望依赖上面一维的状态, 
我们还需要增加一维: 用$f(i, 1)$表示上一家
店铺被抢了, $f(i, 0)$表示上一家店铺没有抢. 因此, 我们就可以转移了. 

这种转移有一些头疼. 于是, 我们可以使用一个特殊的方法 - 请看

TBD: 状态图 % 1 loop 0 to 1 1 to 0

我们下面来正式把这个说一说: 定义$f(i,0)$表示当前站在第$i$个建筑前面, 当前
状态位于$j$的所有走法, 得到的最大值. 下面决定状态转移方程. 考虑$f[i][0]$, 
有哪些走法可以走到0? 其实, 我们可以从上一个0走到0; 或者从1走到0. 因此, 
它们的最大值分别是$f[i-1][0]$和$f[i-1][1]$ - 毕竟没有选择这家店铺. 
下面考虑$f[i][1]$. 我们只能从$f[i-1][0]$走过来. 这样子, 获得的收益是
$f[i-1][0] + w[i]$. 综合去取$\max$即可. 图示如下:

TBD: 图示

\ti{\href{https://www.luogu.com.cn/problem/T294782}{最长公共上升子序列}} 这个问题
我们定义状态$f[i][j]$为所有由第一个序列的前$i$个字母, 第二个序列的前$j$个字母构成的
公共上升子序列, 属性是要求最长的. 但是我们发现在转移的时候因为缺少条件, 我们还需要
知道现在结尾的数是多少, 以便于我们判断是不是可以向后增加. 具体地, 我们这样修改我们的
定义: ``状态$f[i][j]$为所有由第一个序列的前$i$个字母, 第二个序列的前$j$个字母构成的
公共上升子序列, 并且有$b[j]$结尾''. 

那么, 有哪些状态可以转移到了$f[i][j]$呢? 我们可以包含两类: 所有包含$a[i]$的 
公共上升子序列, 另外的是左右不包含$a[i]$的公共上升子序列. 第二类里面, 由于它最后不包含
第$i$个字母, 说明它只可能包含前$i-1$个字母. 即从状态$f[i-1][j]$转移来. 那第一类呢? 
根据状态的定义, 由于同时包含$a[i]$和$b[j]$. 由于$a[i]$是不确定发的, 我们需要继续细分, 
就像刚刚的LCS问题一样. 我们考虑序列的倒数第二个数. 有可能是空, 
$b[1], b[2], \cdots, b[j-1]$. 这样一来, 我们就从实际意义出发, 发现如果是$b[k]$作为
倒数第二个字符的话, 那么值应该是$f[i][k]+1$. 不过这个DP问题可能还需要对代码做等价变形, 
我们来看一看: TBD

现在我们做代码的等价变形, 可以TBD. 

\begin{remark}
    一个问题, 尤其是困难的问题, 搞清楚来龙去脉是重要的. 任何感觉到难的内容可能只是
    缺乏了前置应该了解的东西. 所以, 很多时候, 看一看它的历史, 你就能知道更加多样
    的东西. 甚至追寻着历史的规律, 有一天你也能为解决这一类问题添砖加瓦! 
\end{remark}

\ti{{股票买卖}} 题目叙述: 给一个长度为$N(1\leq N \leq 10^5)$的数组, 数组中的第$i$数字表示给定股票在
第$i$天的价格. 设计一个算法计算能获取的最大利润, 最多完成$k$笔交易. 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）.
一次买入卖出合为一笔交易。第一行包含整数$N,k(1\leq k\leq 100)$, 表示数组长度和最大交易数, 第二行$N$个
不超过10000的正整数, 表示完整的数组. 输出一个整数, 表示最大利润. 

我们发现在例子的情况下, 我们能进行的操作是``买入''和``卖出''. 造成结果是``手中有股''
和``手中无股票''. 这下子, 我们发现最好按照这样的划分方法, 才可以把原来的内容描述
清楚. 如果我们手中有货, 我们在下一天到来的时候既可以继续持有, 或者卖出, 同时得到
一定的收益(得到$w[i]$); 
如果我们手中无货, 那么下一天到来的时候, 我们可以买入 (并付出$w[i]$), 
或者按兵不动. 

我们效仿背包的情况: 假设现在进行到了第$i$天, 正在进行第$j$笔交易(买入就算做这笔交易), 有
$f[i][j][0]=\max(f[i-1][j][0], f[i-1][j-1][1]+w[i])$. 同样的有 
$f[i][j][1]=\max(f[i-1][j][1], f[i-1][j-1][0]-w[i])$. 

\begin{ques}
    如果卖出的时候, 使用了这个会导致全局最大值不对吗? 
\end{ques}

我们会遍历所有的空间, 正如我们前面所说, 这是一个``聪明的搜索'', 所有的状态都会被
计算到的. 

\ti{{\href{https://www.luogu.com.cn/problem/U298750}{股票买卖2}}}
我们这时候发现状态影响决策有手中有货, 手中无货的第一天, 以及手中无货大于等于
第二条(冷冻期). 

TBD: 状态图 手中有货转圈圈(0), 有货->手中无货第一天(+w[i]), 手中无货1->无货的第二天(0) 
手中无货转圈圈(0), 手中无货2->手中有货(-w[i]). 出口有两个

转移方程, 根据上图就有: $f[i][0] = \max(f[i-1][0], f[i-1][2]-w[i])$; 
$f[i][1]=f[i-1][0]+w[i]$, 以及$f[i][2]=\max(f[i-1][1],f[i-1][2])$. 

运用状态机的视角真不错. 我们在很多时候在处理很多问题的时候也可以这样做. 

\section{背包问题} 

背包问题是一类很经典的问题. 我们首先介绍一些常见的策略, 然后仔细看一看
``0-1背包问题''. 背包问题选出的内容里面没有内在的关系. 有时候可以成为组合
类的DP. 

\lec{0-1背包问题}{简介} 简介TBD. 我们考虑设计状态. 

\ti{P1048 采药} 这是一个最为普通的背包问题. 我们现在考虑如何设计方案, 以及有什么
好的办法来做这件事情. 我们设计状态$f[i][j]$表示在集合``考虑前$i$个物品, 总容量
为$j$''的价值的最大值. 那么根据最后一步, 可以把状态表示转化为两大类 - 要么选择第$i$个
要么不选第$i$个. 

不选的方案的话, 那么是$f[i-1][j]$, 如果选取的话, 那么有分为
之前的加上第$i$个. $f[i-1][j-v[i]]+w[i]$. 我们只要找到他们的最大值就好了. 
请看代码\file{P1048-2D}. 


\lec{多重背包问题} TBD 

\section{关于区间的问题}

有些动态规划问题, 我们设计状态需要考察一个区间. 我们从石子合并这个经典问题开始看起. 

\ti{P1775 石子合并(弱化版)} 假设这时候我们认为这是在一条链上的情形. 也就是不能首尾合并.
这时候, 我们定义$f[i][j]$表示所有从$i$到$j$合并的方案, 
属性是最小值. 下面我们来考虑状态的计算问题. 我们来看一看哪个可以到达这个状态. 
我们考虑合并两个区间, 会发现它的分界点不同. 所以这就启发我们使用不同的分界点去
划分现在的集合. 假设分界线落在$k$和$k+1$之间, 那么它需要的体力最小值就是
$f[l][k]+f[k][j]+\text{左右两边的和}$, 也就是先合并左边, 再合右边, 最后就把
两堆合在一起.  最后的是所有的子集的最小值. 状态转移很好写, 但是\textbf{注意循环顺序!}

转移方程: $f[i][j] = \min\{f[i][k]+f[k+1][j]+\sum_{s=i}^j a[i]\}$. 其中$k$从
$i$枚举到$j-1$. 状态空间是$n^2$, 需要枚举起点, 有$\mathcal O(n)$, 总共时间复杂度是
$\mathcal O(n^3)$. 计算$300^3=2.7\times 10^7$, 完全可以. 

接下来我们来看代码: \textbf{请留意循环顺序! } 按照区间长度从小到大枚举. \file{P1775}

从上面的代码中, 一般而言, 区间DP可以首先循环长度, 然后循环左端点, 之后算右端点, 最后枚举
分界点. 这样是使用循环去遍历状态. 正如我们前面所说, 我们也可以使用记忆化搜索的方法
写这个内容, 当转移不明确的时候. 

\begin{ques}
    如果每次允许合并相邻的$n$堆, 应该如何做? 说一说大致思路. 
\end{ques}

我们接下来的问题可以设置状态为前$i$个数成了$j$个的过程. 这相当于DP里面套了一层DP. 
我们这里不做讨论. 

\ti{P1880 石子合并} 下面我们来考虑环形的状况. 我们如何把环的情况展开成一条区间呢? 
因为环形剪掉一条边就成了一个链, 一个朴素的想法是我们
可以枚举缺口在哪. 就可以用区间DP的方法做了. 但这样的时间复杂度是$\mathcal O(n^4)$,
难以接受. 下面介绍一种优化方式: 

我们本质上是$n$个长度为$n$个链的式子合并问题. 我们可以这样做: TBD

这样一来, 我们使用长度为$2n$的区间, 就能保证我们只处理$n$个区间就可以枚举到所有的情况了. 
这样我们的复杂度是$\mathcal O((2n)^3)$. 这样的方法可以处理大多数的环形DP问题. 

请参看代码\file{P1880}. 

\ti{P1063 能量项链} 我们现在断环为链, 像上一个问题一样. 对于一个链, 我们定义状态的表示
$f[i][j]$为所有将$i..j$区间合并成为一个珠子的方式. 属性是维护最大值. 接着来看
合并的时候状态的计算. 我们来看一看哪个可以到达这个状态, 根据最后的不同点来划分. 
这个和上一个是类似的: 有一个分界线(在原来数组的视角下注意这时候是共用的). 根据这个
我们可以把集合划分为若干个子集. 其中分界线分别为$i+1, i+2, \cdots, r-2, r-1$.
假设当前的分界线是$k$的话, 那么就会有将$(i, k), (k, j)$最后将两个合并释放的能量. 
用数学公式写出来就是$f[i][k] + f[k][j] + w[l]\times w[k]\times w[r]$. 
这就是我们使用线性的做法, 现在我们考虑环形的. 运用上一个问题的技巧, 在后面一个$2n$的
链上面做DP就可以了. \file{P1062}

\ti{LOJP10149. \href{https://loj.ac/p/10149}{凸多边形的划分}} 这个问题需要我们一定的观察
与思考. 我们首先发现, 任意作一个三角形, 它就会把左边的和右边的三角形划分开. 因为题目
中有一个重要的条件 -- 互不相交. 这就保证了区间左右的独立性. 所有这样的方案把整个
内容分为了独立的三部分. 这是区间问题里面很重要的一个特征. 我们只要在这个状态下左半边
的划分, 右半边的划分和的最大值, 就可得到和上一个问题一样的想法. 也就是比如我要考虑
从1到$n$的划分, 中间选了点$k$作为分界点, 就有
$f[1][k]+f[k][n]+w[1]\times w[k] \times w[n]$. 我们来求每一个它们的最小值
就可以了. 这一个问题虽然和上一个问题构造非常不同, 但是其转移也非常的相似. 下面我们
详细看一下这个应该如何正式化: 

定义$f[l][r]$维护集合所有将$(l,l+1), (l+1, l+2), \cdots , (r-1, r), (r,l)$
划分为三角形的方案的值的最大值. 在进行状态计算的时候, 我们枚举$l+1, l+2,\cdots, r-2,
r-1$, 就可以把问题分为若干类. 对于每一类, 其转移到当前的值为$f[l][k]+f[k][r]+w[l]*w[k]*w[r]$.

很烦人的地方是, 这个问题需要写高精度. 因为$(10^9)^3\times100$大概会有30位数. 
\codeword{int}的最大值是2147483647, 9位数; \codeword{long long}的最大值是 
9223372036854775808, 19位数.  
我们应该秉持先做对, 再做好的原则进行. 也就是
先做对, 把样例和小测试数据做好, 然后再用高精度写剩余的部分. 
不加高精度的部分如\file{LOJP10149-part}所示. 

下面加上高精度. 为了方便起见我们直接用这个数组存位数, 直接整合进$f$数组里面. 
请看代码的\codeword{add}部分和\codeword{mul}部分. \file{LOJP10149}

\ti{P1040 加分二叉树} 我们看到这个问题, 发现其计算公式很像区间DP的计算的方式: 
分为三个独立的部分. 关键是, 这个中序遍历是不是具有这样的形式, 使得我们可以在上面
做区间DP呢? 

回顾: 现在有一棵树的中序遍历, 我们考察任意的一个子树, 可以发现其在序列里面一定是
连续的一段. 这就让我们可以进行选取根节点进行中序遍历. 我们定义$f[l][r]$为所有将
$l..r$区间构造成一个二叉树的情形. 属性是维护所有二叉树的最大值. 我们找到最后一个
不同点, 根据这些类划分为不同的集合. 我们按照根节点的位置划分. 这样就划分为了若干类.

和上面的问题一样, 如果根节点在第$k$个点的话, 最大值应该如何求? 应该是
$f[l][k-1]\times f[k+1][r]+w[k]$. 下面考虑应该如何记录方案. 

其实记录方案无非是决定最后在更新的时候再某个地方记上一笔: ``节点$k$已经成为了
这个子树的根.'' 于是定义 $g[l][r]$表示 $l..r$ 区间的根节点选哪个. 在输出
前序遍历的时候就先输出这里的根($g[1][n]=:R$)\sn{:=表示``定义做''. 冒号在被定义的表达式那一侧}
, 同时知道左子树的区间和柚子树区间
为$1..R-1, R+1..R$, 反复进行这个过程就行了. 

字典序最小的方案应该如何做? 实际上我们只要让根节点的值最小就好了. 也就是找到
最靠左的一个分界点. 只有在小于当前答案的时候才更新, 并且记录. 如\file{P1040}

我们看一看二维的区间DP. 这时候区间就看上去有点奇怪了. 

\ti{P5752 棋盘分割} 这里面看上去有一个陌生的统计量均方差, 不过不用担心. 
不过我们来看均方差的公式$\sigma = \sqrt{\sum_{i=1}^n(x_i-\overline{x}^2)
\over n}$, 要是想要这个带根号的最小, 就意味着可以求$\sigma^2$最小. 简单变形
就有: \sn{但其实我们可以不用变形的. 这里只是简单体会一下操纵求和记号.}
$$
    \begin{aligned}
        &~{\sum_{i=1}^{n} (x_i-\bar x)^2} \\
        &= \frac1n\sum_{i=1}^{n} (x_i^2-2x_i\bar x+\bar x^2) \\
        &= \frac1n \left(\sum_{i=1}^{n} x_i^2 - \bar x \sum_{i=1}^{n}2x_i + n\bar x^2\right)\\
        &= \frac1n \left(\sum_{i=1}^{n} x_i^2 - \bar x \cdot (2n\bar x) + n\bar x^2\right)\\
        &= \frac{\sum_{i=1}^n x_i^2}{n} - \bar x^2
    \end{aligned}
$$

\begin{remark}
    这个推导在概率论中是比较常见的. 
\end{remark}

这就是我们试图最小化的东西. 也就是所有部分平方和的最小值. 好, 下面我们来看动态规划部分.

定义$f[x_1][y_1][x_2][y_2][k]$表示子矩阵$(x_1, y_1), (x_2, y_2)$切分成
$k$不分的所有方案. 其中$x$是行, $y$是列. 维护的属性是$\sum_{i=1}^n(x_i-\overline{x}^2)$.
的最小值. 

接下来来看状态计算. 我们认为有沿着$x$轴切; 沿着$x$轴切. 一共各自有7种情况, 分别
选上面和下面的情况. 沿着$x$轴切有类似的情况. 
我们的目标是求每一类的最小值, 然后取$\min$. 对于每一类, 我们有上面继续切的分值, 
加上下面剩余的分值. 由于右边的和是固定的, 于是可以用二维的前缀和求出来. 最后求解就可以了. 

如果要用循环来实现, 那么会很复杂. 并且循环的顺序也可能一不留神写错. 这时候我们采用
记忆化搜索的方式完成本问题. \file{5752}

\section{树形DP}
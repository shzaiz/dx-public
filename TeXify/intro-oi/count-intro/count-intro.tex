\part{简单计数问题}

\section{数学基础} 

在阅读数学相关的文献的时候, 我们可能因为数学的记号没有见到, 而产生恐惧. 现在, 我们就对常见的
一些符号做一些简单的认识. 

\lec{逻辑符号}{联词与括号} 数学家喜欢使用一些逻辑连接词来使他们描述的数学对象更加清晰. 符号
$\lnot, \land, \lor,$ $\Rightarrow, \Leftrightarrow$分别表示逻辑上的``非'', ``与'',
``或'', ``可以推出(蕴含)'', ``等价''. 

\begin{example}
    $x^2-3x+2=0$成立, 当$x=1$或$x=2$
    可以用这样的符号表示: $(x^2-3x+2=0) \Leftrightarrow (x=1) \lor (x=2)$. 
\end{example}

同时我们也需要区分必要性和充分性. 这时候我们可以使用真值表的方法来做事情. 另外, 如果
把``若$P$则$Q$''的$P$和$Q$调换一下顺序, 再取反, 得到了$若非Q则非P$, 你会发现, 这两种
说法是等价的. 

并且为了好玩, 我们发现这些内容遵循如下的规律, 为了更清楚地说明, 可以用符号表示. 

\begin{theorem}[最基本的逻辑符号的运算规律]
    我们发现有如下的最基本的运算规律, 以便于我们操作含字母的命题公式. 
    \begin{itemize}[noitemsep]
    
        \item 交换律:
      \[
        (A \land B) \leftrightarrow (B \land A)
      \]
      \[
        (A \lor B) \leftrightarrow (B \lor A)
      \]
    \item 结合律:
      \[
        ((A \land B) \land C) \leftrightarrow (A \land (B \land C))
      \]
      \[
        ((A \lor B) \lor C) \leftrightarrow (A \lor (B \lor C))
      \]
    \item 分配律:
      \[
        (A \land (B \lor C)) \leftrightarrow ((A \land B) \lor (A \land C))
      \]
      \[
        (A \lor (B \land C)) \leftrightarrow ((A \lor B) \land (A \lor C))
      \]
    \item De Morgan律: 
      \[
        \lnot (A \land B) \leftrightarrow (\lnot A \lor \lnot B)
      \]
      \[
        \lnot (A \lor B) \leftrightarrow (\lnot A \land \lnot B)
      \]
      \item 双重否定律:
        \[
            \lnot \lnot A \leftrightarrow A
        \]
        \item 排中律:
        \[
            A \lor (\lnot A)
        \]
        \item 矛盾律:
        \[
            \lnot (A \land \lnot A)
        \]
        \item 逆否命题:
        \[
            (A \to B) \leftrightarrow (\lnot B \to \lnot A)
        \]
    \end{itemize}

\end{theorem}

我们构造的证明, 一般是形如$A\Rightarrow B\Rightarrow C \Rightarrow \cdots \Rightarrow G$.
其中$G$是我们的结论. 在数学中, 每一个关系要么是公理, 要么是由公理推导出来的命题. 

\lec{集合}{基本概念} 我们总是希望把一堆东西放在一起加以研究. 这种趋势再19世纪末已经被
明确提出来了. Cantor等人提出了朴素集合论的思想. Cantor说: ``我们把\textbf{集合}理解
为若干个确定的, 有充分区别的, 具体的或者抽象的对象合并而成的一个整体''. 这种朴素的集合论
的前提是(1) 集合可以由任何有区别的对象构成; (2) 集合由其组成对象唯一确定, (3) 任何性质都可以
确定一个具有该性质对象的集合. 

我们可以用描述的方法表达这个集合的元素是什么. 比如如果我们要表示一个所有的$x$, 满足$x^2-1=0$,
我们就可以这样写: $\{x: x^2-1=0\}.$ 这个冒号有时候也可以写作一个竖线\mn{我们高中学习的
集合就是要写一个竖线. ($\{x | x^2-1=0\}$但是这里由于不与C语言的``或''搞混, 先这样书写. }.

集合中$S$包含元素的个数用$|S|$表示. 有时候称为该集合的``大小(size)''. 很多计数问题
都可以通过这样的一种方法得到更加清晰的表述. 
我们发现, 这个想法和我们以往遇到的数学概念不同, 因为集合的给定方法在明确程度上可以由明显的不同. 
例如``郑州一中的所有学生'', ``集合的集合'', ``Yanyan Jiang中所有a的集合'', ``所有集合的集合''.

甚至最后一个``所有集合的集合'', 干脆就是一个矛盾的概念! 

\begin{proof}
    对于集合$M$, 设记号$P(M)$表示$M$不是它本身的元素. ...
\end{proof}

组成一个集合的对象叫做集合的元素, 如$x$是集合$X$的元素, 可以简单记作$x\in X$(或$X\ni x$). 
如果$x$不是集合$X$的元素, 可以简单记作$x\not \in X$(或$X\not\ni x$). 

\lec{集合}{包含关系} 我们考察集合的交和集合的并, 以及集合的补. 

\begin{definition}
  两个集合的并的定义如下: $A\cup B=\{x:x\in A \lor x\in B\}$
\end{definition}

\begin{definition}
两个集合的交的定义如下: $A\cup B=\{x:x\in A \land x\in B\}$.
\end{definition}

这些就是集合的基本运算了. 我们可以通过这些内容来构造各种不同的东西. 

\lec{映射}{基本的定义}  

映射可以认为是两个集合之间的对应关系. 这有点像送信: 

\begin{definition}[映射]
  设$A,B$ 是两个非空的集合, 如果按某一个确定的对应关系$f$ , 
  使对$A$ 中的任意一个元素$x$ , 在集合$B$ 中都有唯一确定的元素$y$ 与之对应, 
  那么就称对应$f$ 集合 $A$ 到集合 $B$ 的映射. 映射 $f$ 也可记为为$f:A\to B$.
\end{definition}


\lec{映射}{映射的分类} 

映射有很多种类, 根据满足不同的条件, 我们可以将映射分为几种不同的类别：

\begin{definition}
  如果映射$f$的定义域$A$中的每个元素都映射到$B$中的不同元素, 我们就说$f$是"一对一"或"单射". 
\end{definition}

\begin{definition}
  如果映射$f$的值域等于集合$B$, 也就是说$B$中的每个元素都是$f$的某个元素的映像, 那么我们就说$f$是"映满"或"满射". 
\end{definition}

\begin{definition}
  如果映射既是单射又是满射, 那么我们就说它是"一一对应"或"双射". 
\end{definition}

\lec{映射}{复合映射} 那么映射能不能像一条链一样呢? 

其实是可以的. 它是通过将两个或更多的映射联结在一起形成的. 
假设我们有两个映射, $f: A \to B$ 和 $g: B \to C$. 
那么复合映射 $g\circ f: A \to C$ 就定义为对$A$中的每个元素$x$, 
首先应用映射$f$找到元素$f(x)$, 然后应用映射$g$找到元素$g(f(x))$. 
这样便形成了从$A$到$C$的复合映射. 

有时候这个就写作记号$f\circ g$. 注意, 一般来讲$f(g(x))\neq g(f(x))$, 他们是不能交换的, 
但是, 他们是可以结合的. 也就是以什么样的顺序算都是可以的. 

\section{计数原理}

\lec{基本的计数原理}{加法原理} ``加法原理''是计数原理的一个基本策略. 
如果我们有两个不相交 (即互不包含相同元素) 的事件, 其中第一个事件有$n_1$种方式发生, 
第二个事件有$n_2$种方式发生, 那么这两个事件中的任一个发生的方法总数为$n_1 + n_2$. 
也是通常所说的``分步相加''. 局部的之和就是整体的. 下面是形式化的描述. 

\begin{principle}[加法原理]
如果$S$是一个集合, $S$的一个有$m$个部分的划分
\mn{也就是不重复, 不遗漏地把这个集合分成若干部分}$S_1, S_2,\cdots, S_m$, 满足
不遗漏($S=S_1 \cup S_2 \cup S_3 \cup \cdots \cup S_m$); 不重复($\forall 
i,j. S_i \cup S_j = \emptyset$), 那么$|S|=|S_1|+|S_2|+\cdots+|S_n|$. 
\end{principle}

如果一个过程可以通过两个独立的步骤完成, 其中第一步有$m$种可能, 第二步有$n$种可能, 
那么整个过程的总体完成事情的可能的方案数就是$m\times n$. 如果我们用形式化地描述它们
就可以这样说: 

\begin{principle}[乘法原理]
  如果$S$是一个有序对的集合, 里面的元素形如$(a,b )$. 两个有序对$(a_1, b_1), (a_2, b_2)$相等
  当且仅当$a_1=b_1$且$a_2=b_2$. 这样. 如果$a$是从大小为$p$的
  集合里面抽出来的元素之一, $b$是从大小为$q$的
  集合里面抽出来的元素之一, 那么$|S|=p\times q$.
\end{principle}

实际上, 我们可以把每一种选择当做一个``决策'', 平行的(加法原理)选择可以用分叉表示, 递进的
(乘法原理)可以用层层深入表示. 例如下图: TBD. 

下面有一些逆运算. 

\begin{principle}[减法原则]
  如果$A$是一个集合, $U$是一个包含$A$的更大的集合, 那么令$\complement_U A = U\backslash A
  =\{x\in U : x \neq A\}$为$A$相对于$U$的补集. 那么$|A| = |U|-|\complement_U A|$
\end{principle}

\begin{principle}[除法原则]
  如果$S$是一个有限的集合, 划分成了$k$个部分, 每一个部分都有相同的元素, 那么划分的数量$k$就是
  $$k=\frac{|S|}{\text{每一部分有多少个}}. $$
\end{principle}

我们发现, 这些问题相当的基本, 基本到任何一个幼儿园小朋友在刚学习加减乘除的时候都会学习. 
只不过现在我们就可以使用了更加有趣的方法来做了. 理解这些内容你可能知道了为什么幼儿园
小朋友要掰手指头算数了. \mn{事实上, 幼儿园小朋友的这一行为体现的是自然数的递归地定义. 
幼儿园小朋友还是很有智慧的. }

下面我们来考察一个由Gian-Carlo Rota提出的著名的组合问题. 它按照这个方法给我们的计数
问题简单分了一个类. 

\begin{example}[The Twelvefold way]
  我们来看著名的``The Twelvefold Way''这个问题: 
  它包括了12种从有$n$个球放入有$k$个盒子里的方法. 每种方法具有独特的限制, 
  包括球和盒子是否是区分的及是否允许空盒子等. 
  {\center \begin{tabular}[pos]{|c|c|ccc|}
    \hline
    \text{$n$个球} & \text{$k$个盒子} & 想怎么放怎么放 & 每个盒子最多1个球 & 不允许有空盒子   \\
    \hline
    不同的球$\texttt{oO}o$ & 不同的盒子$\fbox{1}~\fbox{2}~\fbox{3}$ & (1) & (2) & (3)\\
    相同的球$\texttt{ooo}$ & 不同的盒子$\fbox{1}~\fbox{2}~\fbox{3}$ & (4) & (5) & (6)\\
    不同的球$\texttt{oO}o$ & 相同的盒子$\fbox{~}~\fbox{~}~\fbox{~}$ & (7) & (8) & (9)\\
    相同的球$\texttt{ooo}$ & 相同的盒子$\fbox{~}~\fbox{~}~\fbox{~}$ & (10) & (11) & (12)\\
    \hline
  \end{tabular}\\}
\end{example}

我们下面来看这个问题. 

\ca{问题(1): $n$个球, $k$个盒子, 盒子和球都是不同的, 随便放} 我们希望做的事情是``把 $n$个球放入$k$个盒子''.
这时候, 我们对于第一个球的选择就随便选一个就好了. 因此有$k$种方法. 对于第二个球, 因为没有限制, 我们照样可以
用$k$种方法...  一直到第$n$个球. 因此总共的方案是$k^n$.

\ca{问题(2): $n$个球, $k$个盒子, 盒子和球都是不同的, 每个盒子最多1个球} 我们假设盒子的个数多于球, 这样
做的事情就会有意义一点. 
我们希望做的事情是``把 $n$个球放入$k$个盒子, 每个盒子最多1个球''.
这时候, 我们对于第一个球的选择就随便选一个就好了. 因此有$k$种方法. 对于第二个球, 因为没有限制, 我们可以
用$k-1$种方法(有一个已经占用了)...  一直到第$n$个球, 就有$k-n+1$个. 因此总共的方案是$k(k-1)(k-2)\cdots(k-n+1)$.

我们一般把这个叫做排列数, 因为它阐述的是从$k$个物品里面选择$n$个数的方法.\mn{注意这里的字母顺序可能和一般的教科书
不同. 一般的教科书习惯写作$A_n^k=n(n-1)\cdots(n-k+1)$. 这里的形式对于内容是没有影响的. 二者阐述的是
同一件事情. } 
同时, 从$k$开始, 往下乘$n$个数也被称作下降幂(falling power). 

\begin{definition}[排列数]
  从$n$个物品里面选择$k$个数的方法数记作排列数. 记作$A_n^k$. 计算方法为
  $$
  A_k^n = k(k-1)(k-2)\cdots(k-n+1)
  $$
  其中$k(k-1)(k-2)\cdots(k-n+1)$可以被记作下降幂, 写作$k^{\underline n}$. 
\end{definition}

\ca{问题(3): $n$个球, $k$个盒子, 盒子和球都是不同的, 不允许有空盒子} 我们发现当我们的球
的数量不少于盒子数量的时候这个内容才有意义. 

既然我不允许有空盒子, 我先随便挑出来$k$个球去``压箱底'', 然后剩下的像刚刚一样
随便放不就好了? 其实这个方法是不对的. 因为这样会算重复一些方案 -- 你默认的要压箱底的和
后来放的在这里是考虑次序的, 而原来的问题是不考虑次序的. 那我们该怎么做? 

这事实上是集合的一个划分. 每一个划分正好对应一个集合. 我们如果能够把这个集合划分为$k$份, 
然后再把每一个划分对应上一个盒子就好了. 第二步很简单, 直接乘上$k!$即可. 

关键是如何划分这个集合? 为了方便我们的符号书写, 我们先记$\left\{{n \atop k}\right\}$ 为把
$n$个集合划分为$k$个部分的个数. 这时候, 我们与其一口吃个胖子, 我们可以一步一步地考虑\mn{这就有点
递归的意思了! 至此, 你应该能感受到为什么我们把递归问题放在第一节了. }

要把$\{1,2,\ldots,n\}$划分为$k$份, 可以借助那些以往的状态可以把我们带到$\stirling n k$. 

第一种情况是, 我们已经把集合$\{1,2,\ldots,{n-1}\}$分为了$k$个部分, 现在的任务是把$n$放入任何
这$k$部分的其中之一. 这就给了我们$k\left\{{n-1 \atop k}\right\}$种方法达到这个目的. 

第二种情况是, 我们已经把$\{1,2,\ldots,{n-1}\}$分为了$k-1$个部分, 并且让$\{n\}$单独一份. 
这样, 我们就有$\left\{{n-1 \atop k-1}\right\}$种方法. 

这两种方法构建的分割是不同的: 因为在第一种方法中, $n$始终位于一个大小$>1$的划分部分中, 
而在第二种方法中, $\{n\}$始终是一个单独的一部分. 因此这两种情况是不重叠的. 
而对于任意一个$n$元素集合分割为$k$份, 必定可以通过这两种方法之一来构建. 因此根据求和法则: 
$$
\left\{{n \atop k}\right\}=k\left\{{n-1 \atop k}\right\}+\left\{{n-1 \atop k-1}\right\}
$$
成立. 

要求得这个递归式的表达式是十分难的. 我们一般到此为止了. 事实上, 这个内容叫做{\textbf{第二类Stirling数(Stirling number of the second kind)}}. 
要计算第二类Stirling数, 我们有如下的公式: 

\begin{definition}[第二类Stirling数]
  将一个大小为$n$的集合划分为$k$个部分的方案数被命名为第二类Stirling数. 记作$\stirling n k$. 
\end{definition}

\begin{theorem}
  第二类Stirling数满足关系
  $$
  \left\{{n \atop k}\right\}=k\left\{{n-1 \atop k}\right\}+\left\{{n-1 \atop k-1}\right\}
  $$
\end{theorem}

于是, 我们一般使用递推计算的方式计算这个集合. 这个确实需要很多思考, 这就是为什么我们会用一个
伟大数学家的名字命名它. 

这下子, 我们就得到了第三个问题的答案: $k! \stirling n k$. 

\ca{问题(5): $n$个相同的球, $k$个不同的盒子, 每个盒子顶多1个球} 这就要求我们搞清楚到底哪个
可以有球, 哪个盒子里面没有球就行了. 所以我们要求从$k$个里面选取$n$个出来. 这个应该如何计算呢? 
实际上, 我们可以先从排列数出发, 然后想一想把它们分成若干个组, 也就是从小到大排个序. 这样子就是
总共的组合数有$A_k^n/k!$个. 为了方便起见, 我们把这个定义做组合数. 

\begin{definition}[组合数]
  从$n$个物品里面选取$k$个数的方案数为组合数, 记作${n\choose k}$, 或者$C_n^k$. 定义为
  $$
  {n\choose k}={n(n-1)(n-2)\cdots(n-k+1)\over k!}
  $$
\end{definition}


\ca{问题(4): $n$个相同的球, $k$个不同的盒子, 随便放} 由于每一个球是相同的, 所以我们需要关注每一个盒子里面
被放了多少球. 因此, 我们就相当于要在这几个球的空档里面``插板''. 由于随意放置, 我们相当于要在$n+k-1$个
里面选出$k$个, 于是, 得到了
$$
{n+k-1\choose k} = \frac{(n+k-1)!}{k!(n-1)!} = {n(n+1)(n+2)\cdots(n+k-1)\over k!}.
$$

我们把这个记作多重组合数的系数(非标准官方译名): 

\begin{definition}[多重集合组合数]
  多重集合的组合数定义为
  $$
  \left(\binom nk\right)=\binom{n+k-1}k=\frac{(n+k-1)!}{k!\left(n-1\right)!}=\frac{n(n+1)(n+2)\cdots(n+k-1)}{k!}.
  $$
  其中, $n(n+1)(n+2)\cdots(n+k-1)$这样的从$n$开始, 向上乘$k$个数这样的被称为上升幂. 方便起见记作
  $n^{\bar k}$
\end{definition}
于是, 我们得到了这个问题的答案: $\binomt kn$. 

\ca{问题(6): $n$个相同的球, $k$个不同的盒子, 每个盒子不许空} 那么我们不妨首先把前几个球放到前几个球里面, 
然后剩下的就得到了不受限制的状况了. 也就是我们这个的答案是${n-1\choose k-1}. $

\ca{问题(7): $n$个不同的球, $k$个相同的盒子, 随便放} 我们可以把$\{1,2,\cdots,n\}$划分进$i$个非空的盒子, 
其中, $i\leq k$. 于是根据加法原理, 这个问题的答案是$\sum_{i=1}^{k}\stirling n i$. 

\ca{问题(8): $n$个不同的球, $k$个相同的盒子, 每个盒子顶多一个球} 事实上, 如果$n>k$, 那么不可能做到.
根据抽屉原理, 总有一个盒子要装两个球. 反之, 我们就可以做到. 于是这个问题的答案是$$\begin{cases}1 & \text{if }n\leq k\\ 0& \text{if }n>k\end{cases}.$$

\ca{问题(9): $n$个不同的球, $k$个相同的盒子, 不允许有空的盒子} 哈哈! 这不就是我们集合划分的定义吗? 
这样, 我们就可以用$\stirling n k$表示了.

\ca{问题(12): $n$个球, $k$个盒子, 盒子和球都相同, 不能有空盒子} 其实这个是
当我们把球放进盒子里面之后, 真正重要的
是什么? 事实上, 我们发现我们只要关心每个盒子有几个球就好了, 并且我们不用关心有多少球的顺序. 
等价地说, 就是把一个整数分拆. 比如7就可以这样分拆成1, 2, $\cdots,$ 7部分:

$$
\begin{aligned}
&\{7\}
& p_1(7)=1\\
&\{1,6\},\{2,5\},\{3,4\}
& p_2(7)=3\\
&\{1,1,5\}, \{1,2,4\}, \{1,3,3\}, \{2,2,3\} 
& p_3(7)=4\\
&\{1,1,1,4\},\{1,1,2,3\}, \{1,2,2,2\}
& p_4(7)=3\\
&\{1,1,1,1,3\},\{1,1,1,2,2\}
& p_5(7)=2\\
&\{1,1,1,1,1,2\}
& p_6(7)=1\\
&\{1,1,1,1,1,1,1\}
& p_7(7)=1
\end{aligned}
$$

等价地说, 我们的要求是一个数$n$的$k$分拆, 分别记作$x_1, x_2, \cdots, x_k$, 满足如下的条件(*): 
\begin{itemize}[noitemsep]
  \item  $x_1\ge x_2\ge\cdots\ge x_k\ge 1$;
  \item $x_1+x_2+\cdots+x_k=n$.
\end{itemize}

为了方便起见, 我们把整数$n$分拆成$k$部分记作$p_k(n)$. 读作``$n$的$k$-分割''下面我们同样用类似于递归的方法
来求解这个问题: 

假设 \((x_1,\ldots,x_k)\) 是 \(n\) 的一个 \(k\)-分割. 满足刚刚我们提到过的条件(*).

我们对这个问题分类讨论: 第一种情况是, 如果 \(x_k = 1\),
那么 \((x_1,\cdots,x_{k-1})\) 是 把\(n-1\) 分割成的一个不同的 \((k-1)\)-分割

第二种情况是, 如果 \(x_k > 1\), 那么 \((x_1-1,\cdots,x_{k}-1)\) 是 \(n-k\) 
的一个不同的 \(k\)-分割. 并且每个 \(n-k\) 的 \(k\)-分割都可以通过这种方式得到. 
因此在这种情况下, \(n\) 的 \(k\)-分割数目为 \(p_k(n-k)\). 

由于所有的情况都已经讨论完毕, 因此, 我们可以使用加法原理, 把这两个部分加起来, 得到了
\(n\) 的 \(k\)-分割数目为 \(p_{k-1}(n-1) + p_k(n-k)\), 即

\[p_k(n)=p_{k-1}(n-1)+p_k(n-k)\,.\]

\begin{definition}[分拆数]
  定义分拆数$p_k(n)$表示把一个正整数$n$分拆为$k$部分, 分别记作$x_1, x_2, \cdots, x_k$, 满足如下的条件
  的个数: 
  \begin{itemize}[noitemsep]
    \item  $x_1\ge x_2\ge\cdots\ge x_k\ge 1$;
    \item $x_1+x_2+\cdots+x_k=n$.
  \end{itemize}
\end{definition}

\begin{theorem}
  分拆数满足性质
  $$p_k(n)=p_{k-1}(n-1)+p_k(n-k)\,.$$
\end{theorem}

所以我们这个问题的答案就是$p_n(k)$. 

\ca{问题(10): $n$个球, $k$个盒子, 盒子和球都相同, 随便放} 
有了分拆数之后, 我们就可以决定到底要分拆多少个了,  于是答案就是$\sum_{i=1}^{k}p_i(n)$. 

\ca{问题(11): $n$个球, $k$个盒子, 盒子和球都相同, 每个盒子顶多1个球} 它和第(8)问的情况类似. 同样要么
能做, 要么不能做. 原理还是依照第八个问题一样. 

这样我们就得到了整个表格的全貌: 

{\center \begin{tabular}[pos]{|c|c|ccc|}
  \hline
  \text{$n$个球} & \text{$k$个盒子} & 想怎么放怎么放 & 每个盒子最多1个球 & 不允许有空盒子   \\
  \hline
  不同的球$\texttt{oO}o$ & 不同的盒子$\fbox{1}~\fbox{2}~\fbox{3}$ & $k^n$ & $k^{\underline n}$ & $n!\stirling nk$\\
  相同的球$\texttt{ooo}$ & 不同的盒子$\fbox{1}~\fbox{2}~\fbox{3}$ & $\binomt kn$ & ${k\choose n}$ & $\binomt{k}{n-k}$\\
  不同的球$\texttt{oO}o$ & 相同的盒子$\fbox{~}~\fbox{~}~\fbox{~}$ & $\sum_{i=1}^k \stirling ni$ & $\begin{cases}1 & \text{if }n\leq k\\ 0& \text{if }n>k\end{cases}$ & $\stirling n k$\\
  相同的球$\texttt{ooo}$ & 相同的盒子$\fbox{~}~\fbox{~}~\fbox{~}$ & $\sum_{i=1}^k p_i(n)$ & $\begin{cases}1 & \text{if }n\leq k\\ 0& \text{if }n>k\end{cases}$ & $p_k(n)$\\
  \hline
\end{tabular}\\}

不要担心这张表格看起来有些复杂. 其实, 这张表格没有记忆的必要. 现在我们只需要学习排列数和组合数就可以建立一个很好的模型了. 
这些概念是非常有趣和实用的, 它们能够帮助我们解决很多有趣的问题. 

上述材料里面的有时候我们还会遇到更加复杂的问题, 比如对于分拆数, 我们需要将一个数分拆成若干个部分, 并且考虑它们之间的顺序. 
都可以通过一些递归的方法来解决. 我们只当做对大家的训练. 一个初学者当然需要看过足够多的例子, 加以大量的思考
才能设计出比较好的这方面的内容. 大家完全不必着急. 

假设我们有$n$个不同的球, $k$个不同的盒子. 我们可以用一个映射的方式来描述不同的放置方法. 
具体来说, 我们可以把每个盒子看作一个“投影”, 而每个球就是我们要放入的“元素”. 
这样, 每一种放置方法就可以看作是一个特定的映射. 

那么, 任意的映射就是我们刚刚的``随便放''; 单射就是我们的``每个盒子只放一个球''; 满射就是``每个盒子不能空''. 
因此, 这个表格更为一般的情况你就能够看得懂了. 

{\center \begin{tabular}[pos]{|c|c|ccc|}
  \hline
  $N$ & $M$ & 任何一个$f:N\to M$ & 单射$f:N\stackrel{\to}{\text{\tiny 1-1}} M$ & 满射$f:N\stackrel{\to}{\text{\tiny onto}} M$   \\
  \hline
  不同的球$\texttt{oO}o$ & 不同的盒子$\fbox{1}~\fbox{2}~\fbox{3}$ & $k^n$ & $k^{\underline n}$ & $n!\stirling nk$\\
  相同的球$\texttt{ooo}$ & 不同的盒子$\fbox{1}~\fbox{2}~\fbox{3}$ & $\binomt kn$ & ${k\choose n}$ & $\binomt{k}{n-k}$\\
  不同的球$\texttt{oO}o$ & 相同的盒子$\fbox{~}~\fbox{~}~\fbox{~}$ & $\sum_{i=1}^k \stirling ni$ & $\begin{cases}1 & \text{if }n\leq k\\ 0& \text{if }n>k\end{cases}$ & $\stirling n k$\\
  相同的球$\texttt{ooo}$ & 相同的盒子$\fbox{~}~\fbox{~}~\fbox{~}$ & $\sum_{i=1}^k p_i(n)$ & $\begin{cases}1 & \text{if }n\leq k\\ 0& \text{if }n>k\end{cases}$ & $p_k(n)$\\
  \hline
\end{tabular}\\}

说了这么多的理论东西, 下面我们来看一看实践的内容吧! 

\ti{P5520 青原樱} 一句话题意: 一共有$n$个位置, $m$棵树, 两棵树之间要有空位, 
问总共有多少种选法. 
我们把这$m$棵树以及他们所占的位置拿出来, 那道路上就剩下$n-m$个坑, 
而这$n-m$个坑有$n-m+1$个空位, 
我们要把带坑的树插进这$n-m+1$个空位中, 一共的插法就有$A_{n-m+1}^m$了.

道理是很简单, 我们应该如何实现求排列数, 组合数的代码呢? 

\lec{排列数}{} 排列数可能是比较直接的. 直接一个\codeword{for}循环就好了. 

\lec{组合数}{递推计算} 第一个想法是我们干脆按照它说的模拟一遍不就好了? 但是问题在于, 
有时候乘上去可能会超出数据的精度与大小, 从而得到错误的结果. 嗯, 我们需要一个优化. 
其实, 组合数有一个很著名的递推关系式, 
$$\binom{n}{k} = \binom{n-1}{k-1} + \binom{n-1}{k}.$$
这个递推关系的意义是，从$n$个元素中选择$k$个元素的组合数等于两部分之和：一部分是从$n-1$个元素中选择$k-1$个元素的组合数，另一部分是从$n-1$个元素中选择$k$个元素的组合数。如果你只想递推某一行
的, 那么你可以使用这个恒等式: $${n\choose k}={n-k+1\over k}{n\choose k-1}.$$
并且从$n\choose 0=1$开始从左往右开始做. 我们可以使用组合数的定义${n\choose k}={n!\over 
k!(n-k)!}$进行证明. 

\ti{\href{https://codeforces.com/problemset/problem/817/B}{CF817B Makes And The Product}}
题目大意: 给定一个长度大于3的数列, 多少个由$(i,j,k)(i < j < k) $, 使得$a_i\cdot a_j\cdot a_k$是最小的? 

我们发现, 最小乘积是由数组的三个比较小元素相乘得到的. 因此首先排个序, 然后分一些情
况来考虑, 分别按照最小的, 第二小的, 第三小的的个数分类\mn{分类的时候一定要注意不重复, 不遗漏
. 很多时候可以按照一个特定的顺序或逻辑执行. }. \file{CF817B}

如果你发现自己很难把问题分清楚, 那么我推荐\href{https://www.bilibili.com/video/BV1C34y1R7wf}{韩老师讲的这系列计数问题}(来自Bilibili: BV1C34y1R7wf)的视频. 虽然
韩老师讲的是数学竞赛相关的内容, 题目类型可能不同, 但是对于思维的品质的要求可能是很相似的. 
\mn{今天的Twelvefold way只是做一个引入. 如果你想了解更多的内容和应用, 欢迎去追完
整个系列. }

\ti{Cantor展开} 很多时候我们会枚举排列, 比如$abc$三个字母的排列有: 
$$
abc, acb, bac, bca, cab, cba
$$
六种. 那么, 上述的内容是字典序排序过后的内容. 我们在搜索的时候或许希望得到他们的
排名, 这样子我们就可以愉快的把一个字符串的状态表示变成一个整数. 再比如, 2个$a$, 
1个$b$, 1个$c$组成的所有的串按照字典序的编号可以如下: 
$$
aabc(1), aacb(2), \cdots, cbaa(12).
$$
我们比如输入一个字符串, 能不能输出它的编号呢? 

首先我们要了解多重集合有多少个排列. 先把所有可能，也就是全排列处理出来，
然后相同元素可以随意互换位置，按照分组的想法``除掉''就行了。
$$
(n_1+n_2+\cdots+n_k)!\over n_1!n_2!\cdots n_k!
$$
有兴趣的同学可以阅读严格证明. 

下面直接求解一般情况的问题（并不限定字母的种类和个数）。设输入串为$S$，记$d(S)$
为S的各个排列中，字典序比S小的串的个数, 则可以用递推法求解$d(S)$.

假设我们输入了caba, 我们就有如下的一张图TBD, 
其中边上的字母表示“下一个字母”，$f(x)$表示多重集 $x$ 的全排列个数。例如，根据第
一个字母，可以把字典序小于caba的字符串分为3种：以a开头的，以b开头的, 以 c 开头的.
分别对应$d(caba)$的3棵子树。以a开头的所有串的字典序都小于caba，
所以剩下的字符可以任意排列，个数为$f(cba)$；同理，以b开头的所有串的字典序也都小于 caba，
个数为$f(caa)$；以c开头的串字典序不一定小于 caba，关键要看后3个字符 , 因此这部分的个
数为$d(aba)$，还需要继续往下分。感兴趣的同学可以参考\ti{P3014 Cow Line S}. 
只不过, 这里面的是具体的例子. 如果希望得到这个题的问题, 可以参考\ti{P2518 计数}. 

\part{数论简介}

\section{整数, Euclid算法}

任何一本书上面的开头好像都喜欢用Euclid算法求解最大公约数开场. 
这是一个十分古老的算法, 但是要是仔仔细细证明这个算法, 还是不那么显然的. 

下面我们来借助这个算法, 来简单回顾一些数论的基本概念. 

要求两个数$m$, $n$的\textbf{最大公因数(greatest common divisor, gcd)}, 
Euclid发现了这样一个算法并声称:$\gcd(m, n) = \gcd(n\%m, n)$. 
这里, 沿用C++里面的取模, $a\%b$的值就等于$a/ b$的余数. 

如果我们用更聪明的记号来表示的话, 或许$a\%b=a-\lfloor a/b\rfloor\times b$. 
就相当于模拟了$b$次减法. $\lfloor x\rfloor$表示$x$下取整. 比如$\lfloor \pi\rfloor=3$. 
这是一个很有趣的小符号, 它实际上表示的是一个不等式的关系. 

因数的概念可能是数学中产生的最自然的概念之一. 
当我们要对一个东西平均的分配的时候, 一个数"能被另一个数整除"这个性质就显得尤其重要. 
\lec{质数与合数}{定义} 这里, 我们发现一些数只能被$1$和这个数本身整除, 
这样的数我们一般叫做\textbf{``质数(prime)"}. 比如$3=1\times3$. 
(其实$3=-1\times -3$, 但是这里我们只考虑这些乘数都是正的). 
还有一些数分解的可能就多了不少. 例如$14=1\times 14 = 2\times 7$. 
这样的数我们称作\textbf{``合数(composite)''}.

\begin{definition}[质数与合数]
    若一个正整数只含有1和它本身这两个不同的正因数, 则称其为素数. 

    若一个正整数出了1和它本身外, 还有其他的因数, 则称为合\mn{合指的是``复合''的意思.}数.

    1既不是素数, 也不是合数. 
\end{definition}

有时候在处理一些证明的时候, 如果题目中告诉了我们$n$是一个合数, 我们可以知道$n=n_1n_2$, 
其中$1\leq n_1, n_2\leq n$. 这样子有时候可以帮助我们分析问题. 



更一般的, 有时候我们仅仅关注一个数能不能被另一个数整除,
也即是$a/ b$的余数是不是为0, 如果是, 
我们就说$b$是$a$的一个\textbf{因子(factor)}. 
有时候可以写作$b|a$. 像是从$a$中"抓出来"了一个它的更小的部分放在前面. 


所以我们有一个形式化的定义: 

\begin{definition}[整除]
    $m | n \iff m>0 \text{ 并且 } \text{对于某个整数}k, n=mk. $
\end{definition}

如果我们抓一个数出来写出它的所有因子, 就会发现因数具有共轭的属性. 意味着$d|n\iff {d\over n}| n$. 
这个问题我们在后续学习Mobius反演系列的内容的时候会频繁地使用这个内容变换和的下标. 

在知道为什么这个算法是对的之前, 我们需要发掘一点整除的性质. 

\lec{整除的性质}{简介} 

\begin{theorem}
    设$a,b,c\in \mathbb Z, c\neq 0$, 我们有如下的性质: 
    \begin{itemize}[noitemsep]
        \item $c|b, b|a \implies c|a$. (整除的传递性)
        \item $b|a \implies cb|ca$.
        \item $c|a, c|b, \implies\forall m,n\in \mathbb Z $, 有$c|(ma+nb)$.(线性组合, 非常重要)
        \item $b|a$, 并且$a\neq 0\implies |b|\leq |a|$. 
        \item $b|a$, 并且$|b|>|a|\implies a=0$.
        \item $a|b, b|a\implies |a|=|b|$.  
    \end{itemize}
\end{theorem}

\begin{proof}
    对于(4)的证明: 因为$b|a$, 所以存在$k\in \mathbb Z$, 使得$a=kb$. 由于$a\neq 0$, 意味着
    $k\neq 0$. 所以$|a|=|kb|=|k||b|\geq|b|$
\end{proof}

\lec{带余除法}{介绍}我们看到了整除的理论, 接下来我们来看带余数的除法有什么值得关注的.

\begin{theorem}[带余除法]
    对于给定整数$a,b,$ 且$b\neq 0$, 必定存在一对整数$q,r$, 使得$a=bq+r$, $0\leq r \leq |b|$.\mn{
        为什么还要证明这样显然的东西? 事实上, 小学时候我们做的事情只是一种给定的情况. 我们很多时候需要做
        一些并不显然的东西. 这里的任意性导致我们必须要证明这样的定理. 数学不是``实验科学''. 
    }
\end{theorem}

\begin{proof}
    存在性: 分类讨论. (1)考虑$b|a$, $\exists k\in \mathbb Z$, 使得$a=kb, $取$q=k, r=0$即为答案. 

    (2) 若$b\not | a, $取这样的集合$S={a-bq: q\in \mathbb Z}$. 其中$a,b$是给定的整数, $q$是可以变化
    的整数. 显然$S$中存在正整数. 必有最小者. 记它为$r$. 下证$0<r<|b|$. 考虑反证法, 如果这个不成立, 
    那么$r\geq |b|$. 
    
    (i)若$r=|b|$, $a-bq=|b|\implies b|a$, 矛盾! 

    (ii) $r>|b|: 0\leq r-|b|=a-bq-|b|=a-b(q\pm 1)\in S$, 但是$r-|b|<r$, 矛盾. 

    唯一性: 假设存在两对整数$q_1, r_1, q_2, r_2, $使得$a=bq_1+r_1=bq_2+r_2$, 移项, 
    $b(q_1-q_2)=r_2-r_1\implies b|(r_2-r_1)$, 并且$|r_2-r_1|<|b|$, 得到$r_2=r_1$, $q_2=q_1$. 
\end{proof}

上面存在性(2)(ii)的内容被称为递降法. 我们想要证明正整数集$S$里面是空集, 可以从它的反面, 即正整数集$S$非空, 
其中必有$S$中的最小元素$x_0$. 但是我们发现某一个$f(x_0)<x_0$, 并且$f(x_0)\in S$. 这就表明出现了矛盾. 
其实$S$就是空集. 

这就可以让我们用$(a,b)$的问题通过做带余除法的方式, 转化为$(b,r)$的化大为小的操作. 

在介绍我们今天的主角Euclid算法之前, 我们先来看一组关于公因数的相关的概念. 

\begin{definition}[公因数(common divisor)和公倍数(common multiple)]
    设$D,d, M, m$以及$a_1, a_2, \cdots, a_n \in \mathbb N_+$: 

    (1) 若$d|a_i,i=1,2,\cdots, n$, 则称$d$是$a_1, a_2, \cdots, a_n$的一个公因数. 
    若$D$是$a_1, \cdots, s_n$的一个公因数, 且对于$a_1, a_2, \cdots, a_n$的任一公因数
    $d|D$, 则称$D$是$a_1, a_2,\cdots, a_n$的最大公因数\mn{这个与
    所有的公因数中的最大者是等价的. 因为我们有整除的性质中的不等式可以知道.
    }. 记作$(a_1, a_2,\cdots, a_n)$或 
    $\gcd(a_1, a_2, a_3, \cdots, a_n)$. 

    (2) 若$a_i | M, i=1,2,3,\cdots, n$, 则称$M$是$a_1, a_2, \cdots, a_n$的一个公倍数. 
    若$M$是$a_1, \cdots, a_n$的一个公倍数, 且对于$a_1, a_2, \cdots, a_n$的任何一个公倍数
    $M$, 都有$m|M$, 则称$m$是$a_1, a_2, \cdots, a_n$的最小公倍数. 记作$[a_1, a_2, \cdots, a_m]$,
    或这$\text{lcm}(a_1, a_2, \cdots, a_m)$. 

    (3) 若$(a_1, a_2, \cdots, a_n) = 1, $那么称$a_1, a_2, \cdots, a_n$互素. 
\end{definition}

在解题中我们经常碰见的是两个数互素. 通俗来讲, 当两个数没有公共的素因子的时候, 就称为他们是互素的. 
另外, 一个更强的条件是两两互素的. 整体互素只要保证他们每一个是没有素因子的, 两两互素要求任意的两个
都没有素因子. 

\lec{Euclid算法}{简介} 欧几里得算法声称, 我们如果要求$(a,b)$的最大公约数, 我们可以对它做带余除法. 
也就是$a=bq+r(0\leq r<b)$, 然后我们就只要求$(b,r)$的最大公因数就行了. 

\begin{theorem}[Euclid算法原理]
    若$a,b\in \mathbb N_+$, $a=bq+r(0\leq r<b)$, 那么$\gcd(a,b) = \gcd(b, r)$. 
\end{theorem}

\begin{proof}
    容易说明$\gcd(a, b)=\gcd(a-b, b)$. 因为如果$d$是$a$的因数, 也是$b$的因数, 那它一定是
    $a$和$b$的一个公因数. 根据整除的性质, $d$一定是$a-b$的因数. 因此$d$就是$a-b$和$b$的公因数. 
    反之, 如果一个数是$(a-b)$的公因数, 同时也是$b$的公因数, 我们很容易推出是$a$的公因数. 它们是
    一一对应的. 自然, 他们的最大公因数是相等的. 由此, $(a,b)=(a-b, b)=(a-2b,b)=\cdots=(a-qb,b)=(b,r)$.
\end{proof}

有了上述的原理, 我们就可以用这样的手段不断化大为小, 直到第二个位置为$0$. 这时候第一个位置就是我们的
最大公因数. 下面只写余数不为0的情况: 这时候, 
\begin{align*}
    b&=rq_1+r_1(0\leq r_1<r) &  0\leq r_1 < r,  & (b, r) = (r, r_1) \\
    r&=r_1q_2+r_2(0\leq r_2<r_1) &  0\leq r_2 < r_1,  & (r, r_1) = (r_1, r_2) \\
    r_1&=r_2q_3+r_3(0\leq r_3<r_2) &  0\leq r_3 < r_2,  & (r_1, r_2) = (r_2, r_3) \\
    &\cdots
\end{align*}

这个方法可以无限地进行下去吗? 其实是不能的. $b>r>r_1>r_2>\cdots\geq0$, 这一定是有限的. 必有一步
余数是0. 我们记作这一步为$r_{n+1}$. 也就是$r_{n-1}=r_nq_{n+1}, $意味着$(r_{n-1}, r_n)=r_n$. 
综上所述, $(a,b)=(b, r)=(r, r_1)=\cdots = (r_{n-1}, r_n)=r_n$. 

用这个方法可以求一系列有趣的例子. 如Fibonacci数列中的一个有趣的性质: 

\begin{example}
    Fibonacci数列是$F_1=1, F_2=1, \forall n\in \mathbb N_+$都有$F_{n+2}=F_{n+1}+F_{n}$. 
    可以证明$(F_m, F_n) = F_{(m, n)}$. 

    仿照刚刚Euclid算法证明的过程, 我们可以尝试证明$(F_m, F_n) = (F_{n-m}, F_m)$. 当$n=m$的时候
    显然成立. 只研究$n>m$的情形. $n=mq+r, 0\leq r <m$. 

    而使用``1''的代换, 因为$F_1=1, F_2=1$, 可以乘上去并且对$F_{n-1}$再用一次. 有
    $F_n=F_{n-1}+F_{n-2}=F_2F_{n-1}+F_1F_{n-2}=F_2(F_{n-2}+F_{n-3})+F_1F_{n-2}$. 也就是
    $F_2F_{n-2}+F_2F_{n-3}+F_1F_{n-2}$, 提取公因式, 就有$F_3F_{n-2}+F_2F_{n-3}$. 继续这样做下去, 
    写作$F_3(F_{n-3}+F_{n-4})+F_2F_{n-3}$. 我们同样可以用同样的方法写作$F_4F_{n-3}+F_3F_{n-4}$, 
    一直做下去, 最后可以得到$F_mF_{n-m+1}+F_{m-1}F_{n-m}$.这里就出现了我们期待已久的$F_m, F_{n-m}$
    的结构了, 如果$d|F_m, d|F_n\implies d|F_{m-1}F_{n-m}$. 我们只要证明
    $F_m, F_{m-1}$是互素的. 根据Fibonacci的性质$(F_m, F_{m-1})=(F_{m-1}, F_{m-2})=\cdots=(F_2,
     F_1)=1$不难看出. 

    反之, $d|F_{n-m}, d|F_m \implies d|F_m, d|F_n$. 我们证得$(F_m, F_n) = (F_{n-m}, F_m)$. 
    持续地辗转相除, 即可得到. 
\end{example}

\lec{Bezout定理}{简介} TBD...Bezout定理可以帮助我们解决这样一类整数不定方程的问题: 

\begin{theorem}
    设$d=(a, b)$, 则存在$x,y\in\mathbb Z$, 使得$xa+yb=d$. 
\end{theorem}

\begin{proof}
    不妨设$a>b>0$, 则$a=bq+r, 0\leq r<b$. 只考虑除了最后一步的各个步骤, 余数大于0的情形. 由于
    $(a, b)=(b, r)$. 根据带余除法的过程, 有: 
    \begin{align*}
        b&=rq_1+r_1 &  0\leq r_1 < r,   \\
        r&=r_1q_2+r_2 &  0\leq r_2 < r_1,   \\
        r_1&=r_2q_3+r_3 &  0\leq r_3 < r_2,   \\
        &\cdots\\
        r_{n-3}&= r_{n-2}q_{n-1}+r_{n-1} & 0\leq r_{n-1}<r_{n-2}\\
        r_{n-2}&= r_{n-1}q_n+r_n & 0\leq r_n<r_{n-1}\\
        r_{n-1}&=r_nq_{n+1}   \\
    \end{align*}
    根据$d=(a, b)=(b,r)=(r, r_1)=(r_1, r_2)=\cdots=(r_{n-1}, r_n)=r_n$, 我们倒推回去
    \begin{align*}
    d&=r_n=r_{n-2}-r_{n-1}q_n \\
    &= r_{n-2}-(r_{n-3}-r_{n-2}q_{n-1}) \\
    &= -q_n r_{n-3}+(1+q_{n-1}q_n)r_{n-2} \\ 
    &\cdots \\
    &= xa+yb, (x, y\in \mathbb Z).
    \end{align*}
\end{proof}

从上面的内容可以看到, $d$可以写作辗转相除过程中, 任意相邻两步余数的线性组合. 那么这个问题的逆命题成立吗? 
这个显然是没有逆命题的. 上面这个定理的逆命题是若$d=(a,b)$, 则存在$x,y\in \mathbb Z$, 使得$xa+yb=d$. 
把这个式子乘上$k$, 得到$(kx)a+(ky)b=kd$, 这就说明有无数个可以表示为$a,b$的整系数线性组合的数. 它们不可能
都是$a,b$的最大公因数. 但是我们可以附加一个条件让我们的这个逆命题成立. 

使得$xa+yb=(a,b)$成立的$x,y$有多少组呢? 其实是有无数组. 只要我找到了其中的一组, 比如叫做$x_0, y_0$, 那么
我们就可以在$x_0$上面加上若干倍的$kb$, 在$y_0$上面减掉若干倍的$ka$, 形成$(x_0+kb)a+(y_0-ka)b$的形式. 
这个同样是满足原来的式子的. 

将上述形式稍加修改, 我们就得到了这个定理具有逆定理的形式. 

\begin{theorem}[充分必要的Bezout定理]
    $(a,b)=d \iff d|a, d|b,$并且$\exists x,y\in \mathbb Z, $使得$xa+yb=d$.
\end{theorem}

\begin{proof}
    必要性上述已经证明, 下面证明充分性. 

    我们先证明一个引理: $(a,b)$是形如$xa+yb(x,y\in \mathbb Z)$的正整数中的最小者. 记
    $S=\{xa+yb: x,y\in \mathbb Z\}, l_0=x_0a+y_0b$是$S$中的最小者. 下面证明$l_0=(a,b)$. 
    从$S$中取出任意的一个$l=xa+yb$, 若记$l_0|l$, 由于$l_0$是正数, 根据带余除法,  $l=l_0q+r, 0\leq r<l_0$.
    $$
    r=l-l_0q=(xa+yb)-(x_0a+y_0b)q=(x-x_0q)a+(y-y_0q)b\in S.
    $$
    但是$r<l_0$, $r$只能等于0. 意味着$l_0$是$l$的因数. 即$l_0|l$

    下面证明$l_0$是$(a,b)$. 一方面, $(a,b) | a, (a, b)| b \implies (a, b)|(x_0a+y_0b)$, 
    也就是$a,b$是$l_0$的因数. 

    另一方面, 由于$a,b\in S\implies l_0 | a, l_0 | b \implies l_0|(a, b)$.

    由于上述两方面, $l_0=(a,b)$. 引理证明完毕. 

    下面证明$l_0$就是$d$. 根据上述的引理, $(a,b)|(xa+yb)=d$, 又因为条件中的$d|a, d|b\implies d|(a,b)$

    所以$d=(a,b)$. 
\end{proof}

事实上, Bezout定理可以推广位$n$个正整数的最大公因数的情形. $\forall a_1, a_2,\cdots, a_n \in \mathbb N_+$,
$\exists k_1, k_2, k_3,\cdots, k_n\in \mathbb Z$, 使得$k_1a_1+k_2a_2+\cdots+k_na_n=(a_1, a_2,\cdots, a_n)$.
另外, 由于系数不唯一可能会导致一些研究的困难. 这时候我们对于系数做一些限定: 

\begin{theorem}
    设$a,b\in \mathbb Z$, $(a, b)=1$, 且$|a|\geq 2, |b|\geq 2$, 则$\exists u_0,v_0\in \mathbb Z$,
    使得$u_0a+v_0b=1,$且$|u_0|<|b|, |v_0|<|a|.$ 
\end{theorem}

\begin{proof}
    根据Bezout定理, 存在$u,v\in \mathbb Z$, 使得 $ua+vb=1$. 一定会有一个$u=qb+u_0$, 其中$0\leq u_0<|b|$,
    $1=ua+vb=(qb+u_0)a+rb=u_0a+(aq+v)b$. 令$v_0=aq+v$, 记作$u_0a+v_0b$. 我们只要证明$|v_0b|<|a|$即可. 

    我们发现$|v_0b|=|1-u_0a|\leq 1+|u_0a|=1+u_0|a|$. 由于$1<|a|$, 我们就知道$1+u_0|a|<|a|+u_0|a|$. 
    也就是$(1+u_0)|a|$. 由于$u_0<|b|, 1+u_0\leq |b|$, 那么继续放大为$|b|\cdot|a|$, 得到$|v_0|<|a|.$
\end{proof}

这个定理可以帮助我们求解一部分不定方程的求解问题. 我们下面来看这个例子: 

\begin{example}
    关于$x,y$的不定方程$ax+by=c(a,b,c\in \mathbb Z, a,b$不全为$0)$, 它有整数解的充要条件是
    $(a,b)|c$. 
    
    对于此的证明, 必要性是显然的, 设$d=(a,b)$, 则$d|ax, d|by, d|ax+by \implies d|c$.

    充分性: $(a,b)|c\implies \exists k\in \mathbb Z$, 使得$c=k(a,b)$. 由Bezout定理, 
    存在$x_0, y_0\in \mathbb Z$, 使得$$x_0a+y_0b=(a,b). $$
    
    将上述的内容两边同时乘上$k$, 有$kx_2a+ky_1b=k(a,b)=c$, 所以$kx_0, ky_0$是方程的一组整数解. 
\end{example}

\lec{算术基本定理}{介绍} 算术基本定理, 也被称为质因数分解定理, 是数论中的一个重要结果. 它告诉我们, 每个大于1
的整数都可以唯一地表示为一系列质数的乘积, 而且这个表示方式是唯一的. 

TBD: 一个无穷维的空间

\begin{theorem}[算术基本定理]
    设$n$是一个大于1的正整数, 则它可以写成$n=p_1p_2\cdots p_k$, 其中$p_i
    (1\leq i\leq k)$都是素数. 且在不计次序的情况下, 该表达式是唯一的. 
\end{theorem}

这个定理表明了每一个自然数的分解都是唯一的. 下面我们来证明. 分为存在性和唯一性两方面.

\begin{proof}
    存在性: 设$n>1$, 且$n\in \mathbb N_+$, 则$n$的最小的
    大于1的素数$p$必为素数. 若$p_1=n$, 则$n$为素数. 否则
    $p_1<n, $则$n/p_1$仍然为一个大于1的整数. 则$n/p_1$的最小的大于
    1的因数记作$p_2$必为素数. 若$p_2=n/p_1$, 
    则$n/p_1$为素数, 也就是$n=p_1p_2$. 

    若$p_2<n/p_1,$则可对$n/(p_1p_2)$重复前面的推理, 直到素数$p_k={n\over p_1p_2\cdots p_k}$,

    唯一性: 我们假设还有另外一个表达式$n=q_1q_2\cdots q_m$. 其中 
    $q_j(1\leq j\leq m)$都是素数. 不妨设$p_1\leq p_2\leq \cdots\leq p_k$,
    $q_1\leq q_2\leq \cdots\leq q_m$. 意味着$q_1|p_1p_2\cdots p_k$.

    回顾这样的一个定理: 如果素数$p|ab$, 那么$p|a$或$p|b$(可由Bezout
    定理推出), 那么$q_1$一定是某一个$p_i(1\leq i\leq k)$, 使得$q_1|p_i$. 
    根据素数的定义, $q_1=p_i$. 同理, $\exists q_j\in {q_1, q_2\cdots,q_m}$, 
    使得$q_j=p_1$. 因为$p_1=q_j\geq q_1=p_i\geq p_i$. 自然而然, $p_1=q_1$. 

    则在等式两边同时约去$p_1$, 重复上述推理. 得$p_2=q_2, p_3=q_3,
    \cdots$直到$q_{k+1}q_{k+2}\cdots q_m=1$, 这在$k<m$的条件下
    不成立. 必然$k=m.$ 唯一性得到证明. 
\end{proof}


TBD : ddl还有三天把正文写完. 